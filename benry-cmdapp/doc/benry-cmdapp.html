<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <meta name="description" content="">
  <meta name="theme-color" content="#fafafa">
  <meta property="og:title" content="">
  <meta property="og:type" content="">
  <meta property="og:url" content="">
  <meta property="og:image" content="">
  <title></title>
  <link rel="stylesheet" href="lib/sanitize.css/2.0.0/sanitize.min.css">
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
<main>
<section class="chapter" id="benry-cmdapp">
<h1>Benry-CmdApp</h1>
<nav class="nav">
  <ul class="nav">
  </ul>
</nav>
<p>($Release: 0.0.0 $)</p>
<section class="section" id="whats-this">
<h2>What's This?</h2>
<p>Benry-CmdApp is a framework to create command-line application.
If you want create command-line application which takes sub-commands
like <code>git</code>, <code>docker</code>, or <code>npm</code>, Benry-CmdApp is the solution.</p>
<p>Basic idea:</p>
<ul>
<li>Action (= sub-command) is defined as a method in Ruby.</li>
<li>Commnad-line arguments are passed to action method as positional arguments.</li>
<li>Command-line options are passed to action method as keyword arguments.</li>
</ul>
<p>For example:</p>
<ul>
<li><code>&ltcommand&gt; hello</code> in command-line invokes action method <code>hello()</code> in Ruby.</li>
<li><code>&ltcommand&gt; hello arg1 arg2</code> invokes <code>hello("arg1", "arg2")</code>.</li>
<li><code>&ltcommand&gt; hello arg --opt=val</code> invokes <code>hello("arg", opt: "val")</code>.</li>
</ul>
<p>Links:</p>
<ul>
<li>Document: <a href="https://kwatch.github.io/benry-ruby/benry-cmdapp.html">https://kwatch.github.io/benry-ruby/benry-cmdapp.html</a></li>
<li>GitHub: <a href="https://github.com/kwatch/benry-ruby/tree/main/benry-cmdapp">https://github.com/kwatch/benry-ruby/tree/main/benry-cmdapp</a></li>
<li>Changes: <a href="https://github.com/kwatch/benry-ruby/tree/main/benry-cmdapp/CHANGES.md">https://github.com/kwatch/benry-ruby/tree/main/benry-cmdapp/CHANGES.md</a></li>
</ul>
<p>Benry-CmdApp requires Ruby &gt;= 2.3.</p>
<section class="subsection" id="table-of-contents">
<h3>Table of Contents</h3>
<div class="toc">
<ul>
<li><a href="#whats-this">What's This?</a></li>
<li><a href="#install">Install</a></li>
<li><a href="#usage">Usage</a>
<ul>
<li><a href="#action">Action</a></li>
<li><a href="#method-name-and-action-name">Method Name and Action Name</a></li>
<li><a href="#parameter-name-in-help-message-of-action">Parameter Name in Help Message of Action</a></li>
<li><a href="#options">Options</a></li>
<li><a href="#option-definition-format">Option Definition Format</a></li>
<li><a href="#option-value-validation">Option Value Validation</a></li>
<li><a href="#callback-for-option-value">Callback for Option Value</a></li>
<li><a href="#boolean-onoff-option">Boolean (On/Off) Option</a></li>
<li><a href="#prefix-of-action-name">Prefix of Action Name</a></li>
<li><a href="#nested-prefix">Nested Prefix</a></li>
<li><a href="#prefix-action-or-alias">Prefix Action or Alias</a></li>
<li><a href="#invoke-other-action">Invoke Other Action</a></li>
<li><a href="#cleaning-up-block">Cleaning Up Block</a></li>
<li><a href="#alias-of-action">Alias of Action</a></li>
<li><a href="#abbreviation-of-prefix">Abbreviation of Prefix</a></li>
<li><a href="#default-action">Default Action</a></li>
<li><a href="#action-list-and-prefix-list">Action List and Prefix List</a></li>
<li><a href="#hidden-action">Hidden Action</a></li>
<li><a href="#hidden-option">Hidden Option</a></li>
<li><a href="#important-actions-or-options">Important Actions or Options</a></li>
</ul></li>
<li><a href="#configuratoin-and-customization">Configuratoin and Customization</a>
<ul>
<li><a href="#application-configuration">Application Configuration</a></li>
<li><a href="#customization-of-global-options">Customization of Global Options</a></li>
<li><a href="#customization-of-global-option-behaviour">Customization of Global Option Behaviour</a></li>
<li><a href="#custom-hook-of-application">Custom Hook of Application</a></li>
<li><a href="#customization-of-application-help-message">Customization of Application Help Message</a></li>
<li><a href="#customization-of-action-help-message">Customization of Action Help Message</a></li>
</ul></li>
<li><a href="#q--a">Q &amp; A</a>
<ul>
<li><a href="#q-how-to-append-some-tasks-to-an-existing-action">Q: How to append some tasks to an existing action?</a></li>
<li><a href="#q-how-to-delete-an-existing-actionalias">Q: How to delete an existing action/alias?</a></li>
<li><a href="#q-how-to-re-define-an-existing-action">Q: How to re-define an existing action?</a></li>
<li><a href="#q-how-to-show-entering-into-or-exitting-from-actions">Q: How to show entering into or exitting from actions?</a></li>
<li><a href="#q-how-to-enabledisable-color-mode">Q: How to enable/disable color mode?</a></li>
<li><a href="#q-how-to-define-a-multiple-option-like--i-option-of-ruby">Q: How to define a multiple option, like <code>-I</code> option of Ruby?</a></li>
<li><a href="#q-how-to-show-global-option--l-topic-in-help-message">Q: How to show global option <code>-L &lttopic&gt;</code> in help message?</a></li>
<li><a href="#q-how-to-specify-detailed-description-of-options">Q: How to specify detailed description of options?</a></li>
<li><a href="#q-how-to-copy-all-options-from-other-action">Q: How to copy all options from other action?</a></li>
<li><a href="#q-what-is-the-difference-between-prefixalias_of-and-prefixaction">Q: What is the difference between <code>prefix(alias_of:)</code> and <code>prefix(action:)</code>?</a></li>
<li><a href="#q-how-to-list-only-aliases-or-actions-excluding-actions-or-aliases-">Q: How to list only aliases (or actions) excluding actions (or aliases) ?</a></li>
<li><a href="#q-how-to-change-the-order-of-options-in-help-message">Q: How to change the order of options in help message?</a></li>
<li><a href="#q-is-it-possible-to-add-metadata-to-actions-or-options">Q: Is it possible to add metadata to actions or options?</a></li>
<li><a href="#how-to-remove-common-help-option-from-all-actions">How to remove common help option from all actions?</a></li>
<li><a href="#q-how-to-make-error-messages-i18ned">Q: How to make error messages I18Ned?</a></li>
</ul></li>
<li><a href="#license-and-copyright">License and Copyright</a></li>
</ul>
</div>
</section>
</section>
<section class="section" id="install">
<h2>Install</h2>
<pre class="language-console">
$ gem install benry-cmdapp
</pre>
</section>
<section class="section" id="usage">
<h2>Usage</h2>
<section class="subsection" id="action">
<h3>Action</h3>
<ul>
<li>Inherit action class and define action methods in it.</li>
<li>An action class can have several action methods.</li>
<li>It is ok to define multiple action classes.</li>
<li>Command-line arguments are passed to action method as positional arguments.</li>
</ul>
<p>File: ex01.rb</p>
<pre class="language-ruby">
# coding: utf-8
<strong>require 'benry/cmdapp'</strong>

## action
class MyAction &lt <strong>Benry::CmdApp::Action</strong>    # !!!!

  <strong>@action.("print greeting message")</strong>      # !!!!
  <strong>def hello(user="world")</strong>                 # !!!!
    puts "Hello, #{user}!"
  end

end

## configuration
config = <strong>Benry::CmdApp::Config.new("sample app", "1.0.0")</strong>

## run application
app = <strong>Benry::CmdApp::Application.new(config)</strong>
status_code = app.main()
exit status_code
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex01.rb <strong>hello</strong>           # action
Hello, world!

[bash]$ ruby ex01.rb <strong>hello Alice</strong>     # action + argument
Hello, <strong>Alice</strong>!
</pre>
<p>Help message of command:</p>
<pre class="language-console">
[bash]$ ruby ex01.rb <strong>-h</strong>     # or `<strong>--help</strong>`
ex01.rb (1.0.0) --- sample app

Usage:
  $ ex01.rb [&ltoptions&gt;] &ltaction&gt; [&ltarguments&gt;...]

Options:
  -h, --help         : print help message (of action if specified)
  -V, --version      : print version
  -l, --list         : list actions
  -a, --all          : list hidden actions/options, too

Actions:
  hello              : print greeting message
  help               : print help message (of action if specified)
</pre>
<p>Help message of action:</p>
<pre class="language-console">
[bash]$ ruby ex01.rb <strong>-h hello</strong>     # or: ruby ex01.rb --help hello
ex01.rb hello --- print greeting message

Usage:
  $ ex01.rb hello [&ltuser&gt;]
</pre>
<ul>
<li>Benry-CmdApp adds <code>-h</code> and <code>--help</code> options to each action automatically.
  Output of <code>ruby ex01.rb hello -h</code> and <code>ruby ex01.rb -h hello</code> will be the same.</li>
</ul>
<pre class="language-console">
[bash]$ ruby ex01.rb <strong>hello -h</strong>     # or: ruby ex01.rb helo --help
ex01.rb hello --- print greeting message

Usage:
  $ ex01.rb hello [&ltuser&gt;]
</pre>
</section>
<section class="subsection" id="method-name-and-action-name">
<h3>Method Name and Action Name</h3>
<ul>
<li>Method name <code>print_</code> results in action name <code>print</code>.
  This is useful to define actions which name is same as Ruby keyword or popular functions.</li>
<li>Method name <code>foo_bar_baz</code> results in action name <code>foo-bar-baz</code>.</li>
<li>Method name <code>foo__bar__baz</code> results in action name <code>foo:bar:baz</code>.</li>
</ul>
<p>File: ex02.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  ## 'print_' =&gt; 'print'
  @action.("sample #1")
  def print<strong>_</strong>()                 # !!!!
    puts __method__
  end

  ## 'foo_bar_baz' =&gt; 'foo-bar-baz'
  @action.("sample #2")
  def foo<strong>_</strong>bar<strong>_</strong>baz()            # !!!!
    puts __method__
  end

  ## 'foo__bar__baz' =&gt; 'foo:bar:baz'
  @action.("sample #3")
  def foo<strong>__</strong>bar<strong>__</strong>baz()          # !!!!
    puts __method__
  end

end

config = Benry::CmdApp::Config.new("test app")
app = Benry::CmdApp::Application.new(config)
status_code = app.main()
exit status_code
</pre>
<p>Help message:</p>
<pre class="language-console">
[bash]$ ruby ex02.rb --help
ex02.rb --- test app

Usage:
  $ ex02.rb [&ltoptions&gt;] &ltaction&gt; [&ltarguments&gt;...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list hidden actions/options, too

Actions:
  <strong>foo-bar-baz</strong>        : sample #2
  <strong>foo:bar:baz</strong>        : sample #3
  help               : print help message (of action if specified)
  <strong>print</strong>              : sample #1
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex02.rb <strong>print</strong>            # `print_` method
print_

[bash]$ ruby ex02.rb <strong>foo-bar-baz</strong>      # `foo_bar_baz` method
foo_bar_baz

[bash]$ ruby ex02.rb <strong>foo:bar:baz</strong>      # `foo__bar__baz` method
foo__bar__baz
</pre>
</section>
<section class="subsection" id="parameter-name-in-help-message-of-action">
<h3>Parameter Name in Help Message of Action</h3>
<p>In help message of an action, positional parameters of action methods are printed under the name conversion rule.</p>
<ul>
<li>Parameter <code>foo</code> is printed as <code>&ltfoo&gt;</code>.</li>
<li>Parameter <code>foo_bar_baz</code> is printed as <code>&ltfoo-bar-baz&gt;</code>.</li>
<li>Parameter <code>foo_or_bar_or_baz</code> is printed as <code>&ltfoo|bar|baz&gt;</code>.</li>
<li>Parameter <code>foobar__xxx</code> is printed as <code>&ltfoobar.xxx&gt;</code>.</li>
</ul>
<p>In addition, positional parameters are printed in different way according to its kind.</p>
<ul>
<li>If parameter <code>foo</code> is required (= doesn't have default value), it will be printed as <code>&ltfoo&gt;</code>.</li>
<li>If parameter <code>foo</code> is optional (= has default value), it will be printed as <code>[&ltfoo&gt;]</code>.</li>
<li>If parameter <code>foo</code> is variable length (= <code>*foo</code> style), it will be printed as <code>[&ltfoo&gt;...]</code>.</li>
</ul>
<p>File: ex03.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("name conversion test")
  def test1(<strong>file_name, file_or_dir, file__html</strong>)  # !!!!
    # ...
  end

  @action.("parameter kind test")
  def test2(<strong>aaa, bbb, ccc=nil, ddd=nil, *eee</strong>)  # !!!!
    # ...
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
status_code = app.main()
exit status_code
</pre>
<p>Help message:</p>
<pre class="language-console">
[bash]$ ruby ex03.rb -h test1
ex03.rb test1 --- name conversion test

Usage:
  $ ex03.rb test1 <strong>&ltfile-name&gt; &ltfile|dir&gt; &ltfile.html&gt;</strong>  # !!!!

[bash]$ ruby ex03.rb -h test2
ex03.rb test2 --- parameter kind test

Usage:
  $ ex03.rb test2 <strong>&ltaaa&gt; &ltbbb&gt; [&ltccc&gt; [&ltddd&gt; [&lteee&gt;...]]]</strong>    # !!!!
</pre>
</section>
<section class="subsection" id="options">
<h3>Options</h3>
<ul>
<li>Action can take command-line options.</li>
<li>Option values specified in command-line are passed to actio method as keyword arguments.</li>
</ul>
<p>File: ex04.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class MyAction &lt Benry::CmdApp::Action

  @action.("print greeting message")
  <strong>@option.(:lang, "-l, --lang=&lten|fr|it&gt;", "language")</strong>   # !!!!
  def hello(user="world", <strong>lang: "en"</strong>)                    # !!!!
    case lang
    when "en" ; puts "Hello, #{user}!"
    when "fr" ; puts "Bonjour, #{user}!"
    when "it" ; puts "Ciao, #{user}!"
    else
      raise "#{lang}: unknown language."
    end
  end

end

config = Benry::CmdApp::Config.new("sample app", "1.0.0")
app = Benry::CmdApp::Application.new(config)
status_code = app.main()
exit status_code
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex04.rb hello
<strong>Hello</strong>, world!

[bash]$ ruby ex04.rb hello <strong>-l fr</strong>            # !!!!
<strong>Bonjour</strong>, world!

[bash]$ ruby ex04.rb hello <strong>--lang=it</strong>        # !!!!
<strong>Ciao</strong>, world!
</pre>
<ul>
<li>An action can have multiple options.</li>
<li>Option format can have indentation spaces, for example <code>'    --help'</code>.</li>
</ul>
<p>File: ex05.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class MyAction &lt Benry::CmdApp::Action

  @action.("print greeting message")
  @option.(:lang  , "-l, --lang=&lten|fr|it&gt;", "language")
  <strong>@option.(:repeat, "    --repeat=&ltN&gt;", "repeat &ltN&gt; times")</strong>  # !!!!
  def hello(user="world", lang: "en", <strong>repeat: "1"</strong>)
    #p repeat.class   #=&gt; String                    # !!!!
    repeat.to_i.times do                            # !!!!
      case lang
      when "en" ; puts "Hello, #{user}!"
      when "fr" ; puts "Bonjour, #{user}!"
      when "it" ; puts "Ciao, #{user}!"
      else
        raise "#{lang}: unknown language."
      end
    end
  end

end

config = Benry::CmdApp::Config.new("sample app", "1.0.0")
app = Benry::CmdApp::Application.new(config)
status_code = app.main()
exit status_code
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex05.rb hello Alice -l fr <strong>--repeat=3</strong>
Bonjour, Alice!
Bonjour, Alice!
Bonjour, Alice!
</pre>
<p>Help message:</p>
<pre class="language-console">
[bash]$ ruby ex05.rb -h hello
ex05.rb hello --- print greeting message

Usage:
  $ ex05.rb hello [&ltoptions&gt;] [&ltuser&gt;]

Options:
  -l, --lang=&lten|fr|it&gt; : language        # !!!!
  <strong>    --repeat=&ltN&gt;   : repeat &ltN&gt; times</strong>   # !!!!
</pre>
<p>For usability reason, Benry-CmdApp supports <code>--lang=&ltval&gt;</code> style of long option
but doesn't support <code>--lang &ltval&gt;</code> style.
Benry-CmdApp regards <code>--lang &ltval&gt;</code> as 'long option without argument'
and 'argument for command'.</p>
<pre class="language-console">
[bash]$ ruby ex05.rb hello <strong>--lang fr</strong>         # ``--lang fr`` != ``--lang=fr``
<strong>[ERROR] --lang: argument required.</strong>
</pre>
</section>
<section class="subsection" id="option-definition-format">
<h3>Option Definition Format</h3>
<p>Option definition format should be one of:</p>
<ul>
<li>(short option) <code>-q</code>  : no values.</li>
<li>(short option) <code>-f &ltfile&gt;</code> : value required.</li>
<li>(short option) <code>-i[&ltwidth&gt;]</code> : value is optional.</li>
<li>(long option) <code>--quiet</code>  : no values.</li>
<li>(long option) <code>--file=&ltfile&gt;</code> : value required.</li>
<li>(long option) <code>--indent[=&ltwidth&gt;]</code> : value is optional.</li>
<li>(short &amp; long) <code>-q, --quiet</code>  : no values.</li>
<li>(short &amp; long) <code>-f, --file=&ltfile&gt;</code> : value required.</li>
<li>(short &amp; long) <code>-i, --indent[=&ltwidth&gt;]</code> : value is optional.</li>
</ul>
<p>File: ex06.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  ## short options
  @action.("short options")
  @option.(:quiet  , <strong>"-q"</strong>        , "quiet mode")     # none
  @option.(:file   , <strong>"-f &ltfile&gt;"</strong> , "filename")       # required
  @option.(:indent , <strong>"-i[&ltN&gt;]"</strong>   , "indent width")   # optional
  def test1(quiet: false, file: nil, indent: nil)
    puts "quiet=#{quiet.inspect}, file=#{file.inspect}, indent=#{indent.inspect}"
  end

  ## long options
  @action.("long options")
  @option.(:quiet  , <strong>"--quiet"</strong>        , "quiet mode")     # none
  @option.(:file   , <strong>"--file=&ltfile&gt;"</strong>  , "filename")       # required
  @option.(:indent , <strong>"--indent[=&ltN&gt;]"</strong> , "indent width")   # optional
  def test2(quiet: false, file: nil, indent: nil)
    puts "quiet=#{quiet.inspect}, file=#{file.inspect}, indent=#{indent.inspect}"
  end

  ## short and long options
  @action.("short and long options")
  @option.(:quiet  , <strong>"-q, --quiet"</strong>        , "quiet mode")    # none
  @option.(:file   , <strong>"-f, --file=&ltfile&gt;"</strong>  , "filename")      # required
  @option.(:indent , <strong>"-i, --indent[=&ltN&gt;]"</strong> , "indent width")  # optional
  def test3(quiet: false, file: nil, indent: nil)
    puts "quiet=#{quiet.inspect}, file=#{file.inspect}, indent=#{indent.inspect}"
  end

end

config = Benry::CmdApp::Config.new("test app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex06.rb test1 <strong>-q -f readme.txt -i4</strong>
quiet=true, file="readme.txt", indent="4"

[bash]$ ruby ex06.rb test2 <strong>--quiet --file=readme.txt --indent=4</strong>
quiet=true, file="readme.txt", indent="4"

[bash]$ ruby ex06.rb test3 <strong>-q -f readme.txt -i4</strong>
quiet=true, file="readme.txt", indent="4"
[bash]$ ruby ex06.rb test3 <strong>--quiet --file=readme.txt --indent=4</strong>
quiet=true, file="readme.txt", indent="4"
</pre>
<p>Optional argument example:</p>
<pre class="language-console">
[bash]$ ruby ex06.rb test1 <strong>-i</strong>                 # ``-i`` results in ``true``
quiet=false, file=nil, <strong>indent=true</strong>
[bash]$ ruby ex06.rb test1 <strong>-i4</strong>                # ``-i4`` results in ``4``
quiet=false, file=nil, <strong>indent="4"</strong>

[bash]$ ruby ex06.rb test2 <strong>--indent</strong>           # ``--indent`` results in ``true``
quiet=false, file=nil, <strong>indent=true</strong>
[bash]$ ruby ex06.rb test2 <strong>--indent=4</strong>         # ``--indent=4`` results in ``4``
quiet=false, file=nil, <strong>indent="4"</strong>
</pre>
<p>Help message:</p>
<pre class="language-ruby">
[bash]$ ruby ex06.rb -h test1
ex06.rb test1 --- short options

Usage:
  $ ex06.rb test1 [&ltoptions&gt;]

Options:
  <strong>-q</strong>                 : quiet mode
  <strong>-f &ltfile&gt;</strong>          : filename
  <strong>-i[&ltN&gt;]</strong>            : indent width

[bash]$ ruby ex06.rb -h test2
ex06.rb test2 --- long options

Usage:
  $ ex06.rb test2 [&ltoptions&gt;]

Options:
  <strong>--quiet</strong>            : quiet mode
  <strong>--file=&ltfile&gt;</strong>      : filename
  <strong>--indent[=&ltN&gt;]</strong>     : indent width

[bash]$ ruby ex06.rb -h test3
ex06.rb test3 --- short and long options

Usage:
  $ ex06.rb test3 [&ltoptions&gt;]

Options:
  <strong>-q, --quiet</strong>        : quiet mode
  <strong>-f, --file=&ltfile&gt;</strong>  : filename
  <strong>-i, --indent[=&ltN&gt;]</strong> : indent width
</pre>
</section>
<section class="subsection" id="option-value-validation">
<h3>Option Value Validation</h3>
<p><code>@option.()</code> can validate option value via keyword argument.</p>
<ul>
<li><code>type: &ltclass&gt;</code> specifies option value class.
  Currently supports <code>Integer</code>, <code>Float</code>, <code>TrueClass</code>, and <code>Date</code>.</li>
<li><code>rexp: &ltrexp&gt;</code> specifies regular expression of option value.</li>
<li><code>enum: &ltarray&gt;</code> specifies available values as option value.</li>
<li><code>range: &ltrange&gt;</code> specifies range of option value.</li>
</ul>
<p>File: ex07.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class MyAction &lt Benry::CmdApp::Action

  @action.("print greeting message")
  @option.(:lang  , "-l, --lang=&lten|fr|it&gt;", "language",
                  <strong>enum: ["en", "fr", "it"]</strong>,         # !!!!
		  <strong>rexp: /\A\w\w\z/</strong>)                 # !!!!
  @option.(:repeat, "    --repeat=&ltN&gt;", "repeat &ltN&gt; times",
                  <strong>type: Integer, range: 1..10</strong>)      # !!!!
  def hello(user="world", lang: "en", repeat: 1)
    #p repeat.class   #=&gt; Integer
    repeat.times do
      case lang
      when "en" ; puts "Hello, #{user}!"
      when "fr" ; puts "Bonjour, #{user}!"
      when "it" ; puts "Ciao, #{user}!"
      else
        raise "#{lang}: unknown language."
      end
    end
  end

end

config = Benry::CmdApp::Config.new("sample app", "1.0.0")
app = Benry::CmdApp::Application.new(config)
status_code = app.main()
exit status_code
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex07.rb hello <strong>-l japan</strong>
<strong>[ERROR] -l japan: Pattern unmatched.</strong>

[bash]$ ruby ex07.rb hello <strong>-l ja</strong>
<strong>[ERROR] -l ja: Expected one of en/fr/it.</strong>

[bash]$ ruby ex07.rb hello <strong>--repeat=abc</strong>
<strong>[ERROR] --repeat=abc: Integer expected.</strong>

[bash]$ ruby ex07.rb hello <strong>--repeat=100</strong>
<strong>[ERROR] --repeat=100: Too large (max: 10).</strong>
</pre>
</section>
<section class="subsection" id="callback-for-option-value">
<h3>Callback for Option Value</h3>
<p><code>@option.()</code> can take a block argument which is a callback for option value.
Callback can:</p>
<ul>
<li>Do custom validation of option value.</li>
<li>Convert option value into other value.</li>
</ul>
<p>File: ex08.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class MyAction &lt Benry::CmdApp::Action

  @action.("print greeting message")
  @option.(:lang  , "-l, --lang=&lten|fr|it&gt;", "language",
                  enum: ["en", "fr", "it", "EN", "FR", "IT"],
		  rexp: /\A\w\w\z/) <strong>{|v| v.downcase }</strong>    # !!!!
  @option.(:repeat, "    --repeat=&ltN&gt;", "repeat &ltN&gt; times",
                  type: Integer) <strong>{|v|</strong>                    # !!!!
		    <strong>v &gt; 0 or raise "Not positive value."</strong> # !!!!
                    <strong>v</strong>                                    # !!!!
                  <strong>}</strong>                                      # !!!!
  def hello(user="world", lang: "en", repeat: 1)
    repeat.times do
      case lang
      when "en" ; puts "Hello, #{user}!"
      when "fr" ; puts "Bonjour, #{user}!"
      when "it" ; puts "Ciao, #{user}!"
      else
        raise "#{lang}: unknown language."
      end
    end
  end

end

config = Benry::CmdApp::Config.new("sample app", "1.0.0")
app = Benry::CmdApp::Application.new(config)
status_code = app.main()
exit status_code
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex08.rb hello <strong>-l FR</strong>   # converted into lowercase
Bonjour, world!

[bash]$ ruby ex08.rb hello <strong>--repeat=0</strong>
<strong>[ERROR] --repeat=0: Not positive value.</strong>
</pre>
</section>
<section class="subsection" id="boolean-onoff-option">
<h3>Boolean (On/Off) Option</h3>
<p>Benry-CmdApp doesn't support <code>--[no-]foobar</code> style option.
Instead, define boolean (on/off) option.</p>
<ul>
<li>Specify <code>type: TrueClass</code> to <code>@option.()</code>.</li>
<li>Option value <code>true</code>, <code>yes</code>, and <code>on</code> are converted into true.</li>
<li>Option value <code>false</code>, <code>no</code>, and <code>off</code> are converted into false.</li>
</ul>
<p>File: ex09.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("flag test")
  @option.(:verbose, <strong>"--verbose[=&lton|off&gt;]"</strong>,  # !!!!
                     "verbose mode",
                     <strong>type: TrueClass</strong>)         # !!!!
  def flagtest(<strong>verbose: false</strong>)                # !!!!
    puts "verbose=#{verbose}"
  end

end

config = Benry::CmdApp::Config.new("sample app", "1.0.0")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex09.rb flagtest --verbose=<strong>on</strong>       # on
verbose=<strong>true</strong>

[bash]$ ruby ex09.rb flagtest --verbose=<strong>off</strong>      # off
verbose=<strong>false</strong>

[bash]$ ruby ex09.rb flagtest --verbose=<strong>true</strong>     # on
verbose=<strong>true</strong>

[bash]$ ruby ex09.rb flagtest --verbose=<strong>false</strong>    # off
verbose=<strong>false</strong>

[bash]$ ruby ex09.rb flagtest --verbose=<strong>yes</strong>      # on
verbose=<strong>true</strong>

[bash]$ ruby ex09.rb flagtest --verbose=<strong>no</strong>       # off
verbose=<strong>false</strong>

[bash]$ ruby ex09.rb flagtest --verbose=<strong>abc</strong>      # error
<strong>[ERROR] --verbose=abc: boolean expected.</strong>
</pre>
<p>If you want default value of flag to <code>true</code>, use <code>value:</code> keyword argument.</p>
<ul>
<li><code>value:</code> keyword argument in <code>@option.()</code> specifies the substitute value
  instead of <code>true</code> when no option value specified in command-line.</li>
</ul>
<p>File: ex10.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("flag test")
  @option.(:verbose, "-q, --quiet", "quiet mode",
                     <strong>value: false</strong>)                 # !!!!
  def flagtest2(<strong>verbose: true</strong>)                     # !!!!
    puts "verbose=#{verbose.inspect}"
  end

end

config = Benry::CmdApp::Config.new("git helper")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex10.rb flagtest2           # true if '--quiet' NOT specified
verbose=<strong>true</strong>

[bash]$ ruby ex10.rb flagtest2 <strong>--quiet</strong>   # false if '--quiet' specified
verbose=<strong>false</strong>

[bash]$ ruby ex10.rb flagtest2 <strong>--quiet=on</strong>   # error
<strong>[ERROR] --quiet=on: Unexpected argument.</strong>
</pre>
<p>In above example, <code>--quiet=on</code> will be error because option is defined as
<code>@option.(:verbose, "-q, --quiet", ...)</code> which means that this option takes no arguments.
If you want to allow <code>--quiet=on</code>, specify option argument and <code>type: TrueClass</code>.</p>
<pre class="language-ruby">
  ...(snip)...

  @action.("flag test")
  @option.(:verbose, "-q, --quiet<strong>[=&lton|off&gt;]</strong>", "quiet mode",  # !!!!
                     <strong>type: TrueClass</strong>, value: false)           # !!!!
  def flagtest2(verbose: true)
    puts "verbose=#{verbose.inspect}"
  end

  ...(snip)...
</pre>
</section>
<section class="subsection" id="prefix-of-action-name">
<h3>Prefix of Action Name</h3>
<ul>
<li><code>prefix "foo:bar:"</code> in action class adds prefix <code>foo:bar:</code> to each action name.</li>
<li>Prefix name shoud end with <code>:</code>. For example, <code>prefix "foo:"</code> is OK but <code>prefix "foo"</code> will be error.</li>
<li>Prefix name should be a string. Symbol is not allowed.</li>
<li>Method name <code>def baz__test()</code> with <code>prefix: "foo:bar"</code> results in action name <code>foo:bar:baz:test</code>.</li>
</ul>
<p>File: ex11.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action
  <strong>prefix "foo:bar:"</strong>                # !!!!

  @action.("test action #1")
  def <strong>test1</strong>()                      # action name: 'foo:bar:test1'
    puts __method__                #=&gt; test1
    puts methods().grep(/test1/)   #=&gt; foo__bar__test1
  end

  @action.("test action #2")
  def <strong>baz__test2</strong>()                 # action name: 'foo:bar:baz:test2'
    puts __method__                #=&gt; baz__test2
    puts methods().grep(/test2/)   #=&gt; foo__bar__baz__test2
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex11.rb -l
Actions:
  <strong>foo:bar:baz:test2</strong>  : test action #2
  <strong>foo:bar:test1</strong>      : test action #1
  help               : print help message (of action if specified)

[bash]$ ruby ex11.rb <strong>foo:bar:test1</strong>
test1                         # &lt== puts __method__
foo__bar__test1               # &lt== puts methods().grep(/test1/)

[bash]$ ruby ex11.rb <strong>foo:bar:baz:test2</strong>
baz__test2                    # &lt== puts __method__
foo__bar__baz__test2          # &lt== puts methods().grep(/test1/)
</pre>
<p>(INTERNAL MECHANISM):
As shown in the above output, Benry-CmdApp internally renames <code>test1()</code> and <code>baz__test2()</code> methods within prefix <code>foo:bar</code> to <code>foo__bar__test1()</code> and <code>foo__bar__baz__test2()</code> respectively.
<code>__method__</code> seems to keep original method name, but don't be fooled, methods are renamed indeed.
Due to this mechanism, it is possible to define the same name methods in different prefixes with no confliction.</p>
<ul>
<li><code>prefix()</code> can take a description text of prefix.
  For example, <code>prefix "foo:", "Bla bla"</code> registers <code>"Bla bla</code> as a description of prefix <code>foo:</code>.
  Description of prefix is displayed in list of prefix list.
  See <a href="#action-list-and-prefix-list">Action List and Prefix List</a> section for details.</li>
</ul>
</section>
<section class="subsection" id="nested-prefix">
<h3>Nested Prefix</h3>
<p><code>prefix()</code> can take a block which represents sub-level of prefix.</p>
<p>File: ex12.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class GitAction &lt Benry::CmdApp::Action
  <strong>prefix "git:"</strong>                   # top level prefix

  @action.("show current status in compact format")
  def status(path=".")
    puts "git status -sb #{path}"
  end

  <strong>prefix "commit:" do</strong>             # sub level prefix

    @action.("create a new commit")
    def create(message: nil)
      puts "git commit"
    end

  end

  <strong>prefix "branch:" do</strong>             # sub level prefix

    @action.("create a new branch")
    def create(branch)
      puts "git checkout -b #{branch}"
    end

  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex12.rb -l
Actions:
  <strong>git:branch:</strong>create  : create a new branch
  <strong>git:commit:</strong>create  : create a new commit
  <strong>git:</strong>status         : show current status in compact format
  help               : print help message (of action if specified)
</pre>
<p>Block of <code>prefix()</code> is nestable.</p>
<p>File: ex13.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class GitAction &lt Benry::CmdApp::Action

  <strong>prefix "git:" do</strong>                 # top level prefix

    @action.("show current status in compact format")
    def status(path=".")
      puts "git status -sb #{path}"
    end

    <strong>prefix "commit:" do</strong>            # sub level prefix

      @action.("create a new commit")
      def create(message: nil)
        puts "git commit"
      end

    end

    <strong>prefix "branch:" do</strong>            # sub level prefix

      @action.("create a new branch")
      def create(branch)
        puts "git checkout -b #{branch}"
      end

    end

  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex13.rb -l
Actions:
  git:branch:create  : create a new branch
  git:commit:create  : create a new commit
  git:status         : show current status in compact format
  help               : print help message (of action if specified)
</pre>
</section>
<section class="subsection" id="prefix-action-or-alias">
<h3>Prefix Action or Alias</h3>
<ul>
<li><code>prefix "foo:bar:", action: "blabla"</code> defines <code>foo:bar</code> action (instead of <code>foo:bar:blabla</code>) with <code>blabla()</code> method.</li>
</ul>
<p>File: ex14.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action
  prefix "foo:bar:", <strong>action: "test3"</strong>      # !!!!

  @action.("test action #1")
  def test1()                 # action name: 'foo:bar:test1'
    puts __method__
  end

  @action.("test action #3")
  def <strong>test3</strong>()                 # action name: 'foo:bar'
    puts __method__
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex14.rb -l
Actions:
  <strong>foo:bar</strong>            : test action #3    # !!!! not 'foo:bar:test3'
  foo:bar:test1      : test action #1
  help               : print help message (of action if specified)

[bash]$ ruby ex14.rb foo:bar:test1
test1

[bash]$ ruby ex14.rb <strong>foo:bar:test3</strong>       # !!!! not available because renamed
[ERROR] foo:bar:test3: Action not found.

[bash]$ ruby ex14.rb <strong>foo:bar</strong>             # !!!! available because renamed
test3
</pre>
<ul>
<li><code>prefix "foo:", alias_of: "blabla"</code> defines <code>foo</code> as an alias of <code>foo:blabla</code> action.
  See <a href="#alias-of-action">Alias of Action</a> section about alias of action.</li>
<p></p>
<li>Keyword arguments <code>action:</code> and <code>alias_of:</code> are exclusive.
  It is not allowed to specify both of them at the same time.
  See <a href="#q-what-is-the-difference-between-prefixalias_of-and-prefixaction">Q: What is the difference between prefix(alias_of:) and prefix(action:)?</a> section for details.</li>
<p></p>
<li>Prefix name and action name should be a string. Notice that Symbol is not allowed.</li>
</ul>
<pre class="language-ruby">
    ## Error because prefix name is a Symbol.
    prefix <strong>:foo</strong>

    ## Error because action name is a Symbol.
    prefix "foo:", action: <strong>:blabla</strong>
</pre>
</section>
<section class="subsection" id="invoke-other-action">
<h3>Invoke Other Action</h3>
<ul>
<li><code>run_action()</code> invokes other action.</li>
<li><code>run_once()</code> invokes other action only once.
  This is equivarent to 'prerequisite task' feature in task runner application.</li>
</ul>
<p>File: ex15.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("create build dir")
  def <strong>prepare</strong>()
    puts <strong>"rm -rf build"</strong>
    puts <strong>"mkdir build"</strong>
  end

  @action.("build something")
  def build()
    <strong>run_once("prepare")</strong>        # !!!!
    <strong>run_once("prepare")</strong>        # skipped because already invoked
    puts "echo 'README' &gt; build/README.txt"
    puts "zip -r build.zip build"
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex15.rb build
<strong>rm -rf build</strong>                          # invoked only once!!!!
<strong>mkdir build</strong>                           # invoked only once!!!!
echo 'README' &gt; build/README.txt
zip -r build.zip build
</pre>
<ul>
<li>Action name should be a string. Symbol is not allowed.</li>
</ul>
<pre class="language-ruby">
    ## Error because action name is not a string.
    run_once(<strong>:prepare</strong>)
</pre>
<ul>
<li>When looped action is detected, Benry-CmdApp aborts action.</li>
</ul>
<p>File: ex16.rb</p>
<pre class="language-ruby">
require 'benry/cmdapp'

class LoopedAction &lt Benry::CmdApp::Action

  @action.("test #1")
  def test1()
    run_once("test2")
  end

  @action.("test #2")
  def test2()
    run_once("test3")
  end

  @action.("test #3")
  def test3()
    <strong>run_once("test1")</strong>          # !!!!
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex16.rb test1
<strong>[ERROR] test1: Looped action detected.</strong>

[bash]$ ruby ex16.rb test3
<strong>[ERROR] test3: Looped action detected.</strong>
</pre>
</section>
<section class="subsection" id="cleaning-up-block">
<h3>Cleaning Up Block</h3>
<ul>
<li><code>at_end { ... }</code> registers a clean-up block that is invoked at end of process (not at end of action).</li>
<li>This is very useful to register clean-up blocks in preparation action.</li>
<li>Registered blocks are invoked in reverse order of registration.
  For example, <code>at_end { puts "A" }; at_end { puts "B" }; at_end { puts "C" }</code> prints "C", "B", and "A" at end of process.</li>
</ul>
<p>File: ex17.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("create build dir")
  def prepare()
    puts "mkdir -p build"
    ## register cleaning up block in preparation task
    <strong>at_end { puts "rm -rf build" }</strong>      # !!!!
  end

  @action.("build something")
  def build()
    run_once("prepare")
    puts "echo 'README' &gt; build/README.txt"
    puts "zip -r build.zip build"
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex17.rb build
mkdir -p build
echo 'README' &gt; build/README.txt
zip -r build.zip build
<strong>rm -rf build</strong>    # !!!! clean-up block invoked at the end of process !!!!
</pre>
</section>
<section class="subsection" id="alias-of-action">
<h3>Alias of Action</h3>
<ul>
<li>Alias of action provides alternative short name of action.</li>
</ul>
<p>File: ex18.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action
  <strong>prefix "foo:bar:"</strong>

  @action.("test action #1")
  def <strong>test1</strong>()                 # action name: 'foo:bar:test1'
    puts __method__
  end

end

<strong>Benry::CmdApp.define_alias "test", "foo:bar:test1"</strong>   # !!!!

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex18.rb <strong>test</strong>             # alias name
test1

[bash]$ ruby ex18.rb <strong>foo:bar:test1</strong>    # original action name
test1
</pre>
<p>Help message:</p>
<pre class="language-console">
[bash]$ ruby ex18.rb -h
ex18.rb --- sample app

Usage:
  $ ex18.rb [&ltoptions&gt;] &ltaction&gt; [&ltarguments&gt;...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list hidden actions/options, too

Actions:
  foo:bar:test1      : test action #1
  help               : print help message (of action if specified)
  <strong>test               : alias of 'foo:bar:test1'</strong>
</pre>
<ul>
<li>Both alias and action names should be string. Symbol is not allowed.</li>
</ul>
<pre class="language-ruby">
## Error because alias name is a Symbol.
Benry::CmdApp.define_alias <strong>:test</strong>, "hello"

## Error because action name is a Symbol.
Benry::CmdApp.define_alias "test", <strong>:hello</strong>
</pre>
<ul>
<li>Target action (second argument of `define_alias()`) can be an array of string
  which contains action name and options.</li>
</ul>
<p>File: ex19.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class MyAction &lt Benry::CmdApp::Action

  @action.("print greeting message")
  @option.(:lang, "-l, --lang=&ltlang&gt;", "language", enum: ["en", "fr", "it"])
  def hello(user="world", lang: "en")
    case lang
    when "en" ; puts "Hello, #{user}!"
    when "fr" ; puts "Bonjour, #{user}!"
    when "it" ; puts "Ciao, #{user}!"
    else
      raise "#{lang}: unknown language."
    end
  end

end

Benry::CmdApp.define_alias("bonjour", <strong>["hello", "--lang=fr"]</strong>)        # !!!!
Benry::CmdApp.define_alias("ciao"   , <strong>["hello", "-l", "it", "Bob"]</strong>)  # !!!!

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex19.rb hello
Hello, world!

[bash]$ ruby ex19.rb <strong>bonjour</strong>           # !!!!
Bonjour, world!

[bash]$ ruby ex19.rb <strong>bonjour Alice</strong>     # !!!!
Bonjour, Alice!

[bash]$ ruby ex19.rb <strong>ciao</strong>              # !!!!
Ciao, Bob!
</pre>
<ul>
<li>It is allowed to define an alias of other alias, but not recommended.</li>
</ul>
<pre>
## define an alias
Benry::CmdApp.define_alias(<strong>"hello-it"</strong>   , ["hello", "-l", "it"])

## define an alias of other alias
Benry::CmdApp.define_alias("ciao"       , <strong>"hello-it"</strong>)   # !!!!
</pre>
<ul>
<li><code>prefix "foo:", alias_of: "bar"</code> defines new alias <code>foo</code> which is an alias of <code>foo:bar</code> action.</li>
</ul>
<p>File: ex20.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class GitAction &lt Benry::CmdApp::Action
  <strong>prefix "git:", alias_of: "status"</strong>

  @action.("show status in compact format")
  def <strong>status</strong>(path=".")
    system "git status -sb #{path}"
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex20.rb -l
Actions:
  <strong>git                : alias of 'git:status'</strong>                      # !!!!
  git:status         : show status in compact format
  help               : print help message (of action if specified)
</pre>
<p>Global option <code>-L alias</code> lists all aliases.
This option is hidden in default, therefore not shown in help message but available in default (for debug purpose).</p>
<pre class="language-console">
[bash]$ ruby ex20.rb -L alias
Aliases:
  git                : alias of 'git:status'
</pre>
</section>
<section class="subsection" id="abbreviation-of-prefix">
<h3>Abbreviation of Prefix</h3>
<p>Abbreviation of prefix is a shortcut of prefix.
For example, when <code>b:</code> is an abbreviation of a prefix <code>git:branch:</code>, you can invoke <code>git:branch:create</code> action by <code>b:create</code>.</p>
<p>File: ex21.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class GitAction &lt Benry::CmdApp::Action

  prefix "git:" do

    prefix "branch:" do

      @action.("create a new branch")
      def create(branch)
        puts "git checkout -b #{branch}"
      end

    end

  end

end

## define abbreviation 'b:' of prefix 'git:branch:'
Benry::CmdApp.<strong>define_abbrev("b:", "git:branch:")</strong>     # !!!!

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex21.rb <strong>b:create</strong> topic1    # invokes 'git:branch:create' !!!!
git checkout -b topic1
</pre>
<p>Global option <code>-L abbrev</code> lists all abbreviations.
This option is hidden in default, therefore not shown in help message but available in default (for debug purpose).</p>
<pre class="language-console">
[bash]$ ruby ex21.rb <strong>-L abbrev</strong>
Abbreviations:
  <strong>b:         =&gt;  git:branch:</strong>
</pre>
</section>
<section class="subsection" id="default-action">
<h3>Default Action</h3>
<ul>
<li><code>config.default_action = "test1"</code> defines default action.
  In this case, action <code>test1</code> will be invoked if action name not specified in command-line.</li>
<li>Default action name is shown in help message.</li>
</ul>
<p>File: ex22.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("test action #1")
  def test1()
    puts __method__
  end

end

config = Benry::CmdApp::Config.new("sample app")
<strong>config.default_action = "test1"</strong>     # !!!!
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex22.rb test1
test1

[bash]$ <strong>ruby ex22.rb</strong>               # no action name!!!!
test1
</pre>
<p>Help message:</p>
<pre class="language-console">
[bash]$ ruby ex22.rb -h
ex22.rb --- sample app

Usage:
  $ ex22.rb [&ltoptions&gt;] &ltaction&gt; [&ltarguments&gt;...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list hidden actions/options, too

Actions: <strong>(default: test1)</strong>                   # !!!!
  help               : print help message (of action if specified)
  test1              : test action #1
</pre>
</section>
<section class="subsection" id="action-list-and-prefix-list">
<h3>Action List and Prefix List</h3>
<p>When <code>config.default_action</code> is not specified, Benry-CmdAction lists action names if action name is not specified in command-line.</p>
<p>File: ex23.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("test action #1")
  def <strong>test1</strong>()
  end

  <strong>prefix "foo:"</strong> do

    @action.("test action #2")
    def <strong>test2</strong>()
    end

  end

  <strong>prefix "bar:"</strong> do

    @action.("test action #3")
    def <strong>test3</strong>()
    end

    <strong>prefix "baz:"</strong> do

      @action.("test action #4")
      def <strong>test4</strong>()
      end

    end

  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex23.rb            # no action name!!!!
Actions:
  <strong>bar:baz:test4</strong>      : test action #4
  <strong>bar:test3</strong>          : test action #3
  <strong>foo:test2</strong>          : test action #2
  <strong>help</strong>               : print help message (of action if specified)
  <strong>test1</strong>              : test action #1
</pre>
<p>Command-line option <code>-l, --list</code> also prints the same result of the above example.
This is useful if you specify default action name wit <code>config.default_action</code>.</p>
<p>Action name list contains alias names, too.
If you want to list only action names (or alias names), specify <code>-L action</code> or <code>-L alias</code> option.
See <a href="#q-how-to-list-only-aliases-or-actions-excluding-actions-or-aliases-">Q: How to list only aliases (or actions) excluding actions (or aliases) ?</a> for details.</p>
<p>If prefix (such as <code>xxx:</code>) is specified instead of action name,
Benry-CmdApp lists action names which have that prefix.</p>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex23.rb <strong>foo:</strong>              # !!!!
Actions:
  <strong>foo:test2</strong>          : test action #2

[bash]$ ruby ex23.rb <strong>bar:</strong>              # !!!!
Actions:
  <strong>bar:baz:test4</strong>      : test action #4
  <strong>bar:test3</strong>          : test action #3
</pre>
<p>If <code>:</code> is specified instead of action name, Benry-CmdApp lists top prefixes of action names and number of actions under the each prefix.</p>
<p>Outuput:</p>
<pre class="language-console">
[bash]$ ruby ex23.rb <strong>:</strong>                 # !!!!
Prefixes: (depth=1)
  <strong>bar: (2)</strong>           # !!! two actions ('bar:test3' and 'bar:baz:test4')
  <strong>foo: (1)</strong>           # !!! one action ('foo:text2')
</pre>
<p>In the above example, only top level prefixes are displayed.
If you specified <code>::</code> instead of <code>:</code>, two-level prefixes are displayed,
for example <code>foo:xxx:</code> and <code>foo:yyy:</code>.
Of course, <code>:::</code> displays more level prefixes.</p>
<p>File: ex24.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class GitAction &lt Benry::CmdApp::Action
  prefix "git:"

  prefix "staging:" do
    @action.("...");  def add(); end
    @action.("...");  def show(); end
    @action.("...");  def delete(); end
  end

  prefix "branch:" do
    @action.("...");  def list(); end
    @action.("...");  def switch(name); end
  end

  prefix "repo:" do
    @action.("...");  def create(); end
    @action.("...");  def init(); end

    prefix "config:" do
      @action.("...");  def add(); end
      @action.("...");  def delete(); end
      @action.("...");  def list(); end
    end

    prefix "remote:" do
      @action.("...");  def list(); end
      @action.("...");  def set(); end
    end

  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex24.rb <strong>:</strong>
Prefixes: (depth=<strong>1</strong>)
  git: (12)

[bash]$ ruby ex24.rb <strong>::</strong>             # !!!!
Prefixes: (depth=<strong>2</strong>)
  git: (0)
  <strong>git:branch:</strong> (2)
  <strong>git:repo:</strong> (7)
  <strong>git:staging:</strong> (3)

[bash]$ ruby ex24.rb <strong>:::</strong>            # !!!!
Prefixes: (depth=<strong>3</strong>)
  git: (0)
  git:branch: (2)
  git:repo: (2)
  <strong>git:repo:config:</strong> (3)
  <strong>git:repo:remote:</strong> (2)
  git:staging: (3)
</pre>
<p><code>prefix()</code> can take a description of prefix as 2nd argument.
Descriptions of prefix are displayed in the prefix list.</p>
<p>File: ex25.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  prefix "foo:"<strong>, "description of Foo"</strong> do
    @action.("test action #2")
    def test2()
    end
  end

  prefix "bar:"<strong>, "description of Bar"</strong> do
    @action.("test action #3")
    def <strong>test3</strong>()
    end

    prefix "baz:"<strong>, "description fo Baz"</strong> do
      @action.("test action #4")
      def <strong>test4</strong>()
      end
    end
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex25.rb <strong>:</strong>                       # !!!!
Prefixes: (depth=1)
  bar: (2)           : <strong>description of Bar</strong>    # !!!!
  foo: (1)           : <strong>description of Foo</strong>    # !!!!
</pre>
</section>
<section class="subsection" id="hidden-action">
<h3>Hidden Action</h3>
<ul>
<li>If <code>hidden: true</code> keyword argument passed to <code>@action.()</code>,
  or action method is private, then Benry-CmdApp regards that action as hidden.</li>
<li>Hidden actions are not shown in help message nor action list by default.</li>
<li>Hidden actions are shown when <code>-a</code> or <code>--all</code> option is specified in command-line.</li>
</ul>
<p>File: ex26.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("test action #1")
  def test1()
    puts __method__
  end

  @action.("test action #2", <strong>hidden: true</strong>)  # !!!!
  def test2()
    puts __method__
  end

  <strong>private</strong>                      # !!!!

  @action.("test action #3")
  def test3()
    puts __method__
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Action list (without <code>-a</code> nor <code>--all</code>):</p>
<pre class="language-console">
[bash]$ ruby ex26.rb
Actions:
  help               : print help message (of action if specified)
  test1              : test action #1
</pre>
<p>Action list (with <code>-a</code> or <code>--all</code>):</p>
<pre class="language-console">
[bash]$ ruby ex26.rb <strong>--all</strong>      # !!!!
Actions:
  help               : print help message (of action if specified)
  test1              : test action #1
  <strong>test2              : test action #2</strong>          # !!!!
  <strong>test3              : test action #3</strong>          # !!!!
</pre>
</section>
<section class="subsection" id="hidden-option">
<h3>Hidden Option</h3>
<ul>
<li>Options defined with <code>hidden: true</code> keyword argument are treated as hidden option.</li>
<li>Hidden options are not shown in help message of action.</li>
<li>Hidden options are shown when <code>-a</code> or <code>--all</code> option is specified in command-line.</li>
</ul>
<p>File: ex27.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("test action")
  @option.(:verbose, "-v", "verbose mode")
  @option.(:debug , "-D", "debug mode", <strong>hidden: true</strong>)      # !!!!
  def test1(verbose: false, debug: false)
    puts "verbose=#{verbose}, debug=#{_debug}"
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Help message (without <code>-a</code> nor <code>--all</code>):</p>
<pre class="language-console">
[bash]$ ruby ex27.rb -h test1
ex27.rb test1 --- test action

Usage:
  $ ex27.rb test1 [&ltoptions&gt;]

Options:
  -v                 : verbose mode
</pre>
<p>Help message (with <code>-a</code> or <code>--all</code>)</p>
<pre class="language-console">
[bash]$ ruby ex27.rb -h <strong>--all</strong> test1           # !!!!
ex27.rb test1 --- test action

Usage:
  $ ex27.rb test1 [&ltoptions&gt;]

Options:
  <strong>-h, --help         : print help message</strong>     # !!!!
  -v                 : verbose mode
  <strong>-D                 : debug mode</strong>             # !!!!
</pre>
<p>In the above example, <code>-h, --help</code> option as well as <code>-D</code> option is shown.
In fact, Benry-CmdApp automatically adds <code>-h, --help</code> option to each action in hidden mode.
Therefore all actions accept <code>-h, --help</code> option.</p>
<p>For this reason, you should NOT define <code>-h</code> or <code>--help</code> options for your actions.</p>
</section>
<section class="subsection" id="important-actions-or-options">
<h3>Important Actions or Options</h3>
<p>It is possible to mark actions or options as important or not.</p>
<ul>
<li>Actions or options marked as important are emphasized in help message.</li>
<li>Actions or options marked as not important are weaken in help message.</li>
</ul>
<p>File: ex28.rb</p>
<pre class="language-ruby">
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("important action", <strong>important: true</strong>)   # !!!!
  def test1()
  end

  @action.("not important action", <strong>important: false</strong>)   # !!!!
  def test2()
  end

  @action.("sample")
  @option.(:foo, "--foo", "important option", <strong>important: true</strong>)
  @option.(:bar, "--bar", "not important option", <strong>important: false</strong>)
  def test3(foo: nil, bar: nil)
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex28.rb -l
Actions:
  help               : print help message (of action if specified)
  <strong>test1              : important action</strong>      # !!!! bold font !!!!
  <strong>test2              : not important action</strong>  # !!!! gray color !!!!
  test3              : sample

[bash]$ ruby ex28.rb -h test3
ex28.rb test3 --- sample

Usage:
  $ ex28.rb test3 [&ltoptions&gt;]

Options:
  <strong>--foo              : important option</strong>      # !!!! bold font !!!!
  <strong>--bar              : not important option</strong>  # !!!! gray color !!!!
</pre>
</section>
</section>
<section class="section" id="configuratoin-and-customization">
<h2>Configuratoin and Customization</h2>
<section class="subsection" id="application-configuration">
<h3>Application Configuration</h3>
<p><code>Benry::CmdApp::Config</code> class configures application behaviour.</p>
<ul>
<li><code>config.app_desc = "..."</code> sets command description which is shown in help message. (required)</li>
<li><code>config.app_version = "1.0.0"</code> enables <code>-V</code> and <code>--version</code> option, and prints version number if <code>-V</code> or <code>--version</code> option specified. (default: <code>nil</code>)</li>
<li><code>config.app_command = "&ltcommand&gt;"</code> sets command name which is shown in help message. (default: <code>File.basname($0)</code>)</li>
<li><code>config.app_name = "&ltstring&gt;"</code> sets application name which is shown in help message. (default: same as <code>config.app_command</code>)</li>
<li><code>config.app_usage = "&lttext&gt;" (or </code>["&lttext1&gt;", "&lttext2&gt;", ...]<code>) sets usage string in help message. (default: </code>" &ltaction&gt; [&ltarguments&gt;...]"``)</li>
<li><code>config.app_detail = "&lttext&gt;"</code> sets detailed description of command which is showin in help message. (default: <code>nil</code>)</li>
<li><code>config.help_postamble = {"&ltTitle&gt;:" =&gt; "&lttext&gt;"}</code> sets postamble of help message, such as 'Example:' or 'Tips:'. (default: <code>nil</code>)</li>
<li><code>config.default_action = "&ltaction&gt;"</code> sets default action name. (default: <code>nil</code>)</li>
<li><code>config.option_help = true</code> enables <code>-h</code> and <code>--help</code> options. (default: <code>true</code>)</li>
<li><code>config.option_version = true</code> enables <code>-V</code> and <code>--version</code> options. (default: <code>true</code> if <code>app_version</code> provided, <code>false</code> if else)</li>
<li><code>config.option_list = true</code> enables <code>-l</code> and <code>--list</code> options. (default: <code>true</code>)</li>
<li><code>config.option_target = true</code> enables <code>-L &lttarget&gt;</code> option. (default: <code>:hidden</code>)</li>
<li><code>config.option_all = true</code> enables <code>-a</code> and <code>--all</code> options which shows private (hidden) actions and options into help message. (default: <code>true</code>)</li>
<li><code>config.option_verbose = true</code> enables <code>-v</code> and <code>--verbose</code> options which sets <code>$QUIET_MODE = false</code>. (default: <code>false</code>)</li>
<li><code>config.option_quiet = true</code> enables <code>-q</code> and <code>--quiet</code> options which sets <code>$QUIET_MODE = true</code>. (default: <code>false</code>)</li>
<li><code>config.option_color = true</code> enables <code>--color[=&lton|off&gt;]</code> option which sets <code>$COLOR_MODE = true/false</code>. This affects to help message colorized or not. (default: <code>false</code>)</li>
<li><code>config.option_debug = true</code> enables <code>-D</code> and <code>--debug</code> options which sets <code>$DEBUG_MODE = true</code>. (default: <code>:hidden</code>)</li>
<li><code>config.option_trace = true</code> enables <code>-T</code> and <code>--trace</code> options. Entering into and exitting from action are reported when trace mode is on. (default: <code>false</code>)</li>
<li><code>config.format_option = "  %-18s : %s"</code> sets format of options in help message. (default: <code>"  %-18s : %s"</code>)</li>
<li><code>config.format_action = "  %-18s : %s"</code> sets format of actions in help message. (default: <code>"  %-18s : %s"</code>)</li>
<li><code>config.format_usage = "  $ %s"</code> sets format of usage in help message. (default: <code>"  $ %s"</code>)</li>
</ul>
<p>File: ex31.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

config = Benry::CmdApp::Config.new("sample app", "1.0.0", app_name: "Sample App")
config.each(sort: false) do |name, val|
  puts "config.%-20s = %s" % [name, val.inspect]
end
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex31.rb
config.<strong>app_desc</strong>             = "sample app"
config.<strong>app_version</strong>          = "1.0.0"
config.<strong>app_name</strong>             = "Sample App"
config.<strong>app_command</strong>          = "ex31.rb"             # == File.basename($0)
config.<strong>app_usage</strong>            = nil
config.<strong>app_detail</strong>           = nil
config.<strong>default_action</strong>       = nil
config.<strong>help_postamble</strong>       = nil
config.<strong>format_option</strong>        = "  %-18s : %s"
config.<strong>format_action</strong>        = "  %-18s : %s"
config.<strong>format_usage</strong>         = "  $ %s"
config.<strong>format_prefix</strong>        = nil
config.<strong>deco_command</strong>         = "\e[1m%s\e[0m"        # bold
config.<strong>deco_header</strong>          = "\e[1;34m%s\e[0m"     # bold, blue
config.<strong>deco_strong</strong>          = "\e[1m%s\e[0m"        # bold
config.<strong>deco_weak</strong>            = "\e[2m%s\e[0m"        # gray color
config.<strong>deco_hidden</strong>          = "\e[2m%s\e[0m"        # gray color
config.<strong>deco_error</strong>           = "\e[31m%s\e[0m"       # red
config.<strong>option_help</strong>          = true
config.<strong>option_version</strong>       = true
config.<strong>option_list</strong>          = true
config.<strong>option_all</strong>           = true
config.<strong>option_verbose</strong>       = false
config.<strong>option_quiet</strong>         = false
config.<strong>option_color</strong>         = false
config.<strong>option_debug</strong>         = :hidden
config.<strong>option_trace</strong>         = false
config.<strong>trace_mode</strong>           = nil
</pre>
<p>You may notice that the value of <code>config.option_debug</code> is <code>:hidden</code>.
If value of <code>config.option_xxxx</code> is <code>:hidden</code>, then corresponding global option is enabled as hidden option.
Therefore you can see <code>--debug</code> option in help message if you add <code>-h</code> and <code>-a</code> (or <code>--all</code>) option.</p>
<p>Help message:</p>
<pre class="language-console">
$ ruby ex27.rb -h <strong>-a</strong>                          # !!!!
ex27.rb --- sample app

Usage:
  $ ex27.rb [&ltoptions&gt;] &ltaction&gt; [&ltarguments&gt;...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list hidden actions/options, too
      <strong>--debug        : debug mode</strong>             # !!!!

Actions:
  help               : print help message (of action if specified)
  test1              : test action
</pre>
</section>
<section class="subsection" id="customization-of-global-options">
<h3>Customization of Global Options</h3>
<p>To add custom global options:</p>
<ul>
<li>(1) Create a global option schema object.</li>
<li>(2) Add custom options to it.</li>
<li>(3) Pass it to <code>Application.new()</code>.</li>
</ul>
<p>File: ex32.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("test action")
  def test1()
    puts __method__
  end

end

## (1) create global option shema
config = Benry::CmdApp::Config.new("sample app")
<strong>schema = Benry::CmdApp::GlobalOptionSchema.new(config)</strong>  # !!!!

## (2) add custom options to it
<strong>schema.add(:logging, "--logging", "enable logging")</strong>    # !!!!

## (3) pass it to ``Application.new()``
app = Benry::CmdApp::Application.new(config, <strong>schema</strong>)   # !!!!

exit app.main()
</pre>
<p>Help message:</p>
<pre class="language-console">
[bash]$ ruby ex32.rb -h
ex32.rb --- sample app

Usage:
  $ ex32.rb [&ltoptions&gt;] &ltaction&gt; [&ltarguments&gt;...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list hidden actions/options, too
  <strong>--logging          : enable logging</strong>          # !!!!

Actions:
  help               : print help message (of action if specified)
  test1              : test action
</pre>
<p>To customize global options entirely:</p>
<ul>
<li>(1) Create empty <code>GlobalOptionSchema</code> object.</li>
<li>(2) Add global options as you want.</li>
<li>(3) Create and execute Application object with it.</li>
</ul>
<p>File: ex33.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

## (1) Create empty ``GlobalOptionSchema`` object.
<strong>schema = Benry::CmdApp::GlobalOptionSchema.new(nil)</strong>   # !!!!

## (2) Add global options as you want.
<strong>schema.add</strong>(:help   , "-h, --help"   , "print help message")
<strong>schema.add</strong>(:version, "-V, --version", "print version")
<strong>schema.add</strong>(:list   , "-l, --list"   , "list actions")
<strong>schema.add</strong>(:all    , "-a, --all"    , "list hidden actions/options, too")
<strong>schema.add</strong>(:verbose, "-v, --verbose", "verbose mode")
<strong>schema.add</strong>(:quiet  , "-q, --quiet"  , "quiet mode")
<strong>schema.add</strong>(:color  , "--color[=&lton|off&gt;]", "enable/disable color mode", type: TrueClass)
<strong>schema.add</strong>(:debug  , "-D, --debug"  , "set $DEBUG_MODE to true")
<strong>schema.add</strong>(:trace  , "-T, --trace"  , "report enter into and exit from action")

## (3) Create and execute Application object with it.
config = Benry::CmdApp::Config.new("sample app", "1.0.0")
app = Benry::CmdApp::Application.new(config, <strong>schema</strong>)  # !!!!
exit app.main()
</pre>
<p>Help message:</p>
<pre class="language-console">
[bash]$ ruby ex33.rb -h
ex33.rb (1.0.0) --- sample app

Usage:
  $ ex33.rb [&ltoptions&gt;] &ltaction&gt; [&ltarguments&gt;...]

Options:
  <strong>-h, --help         : print help message</strong>
  <strong>-V, --version      : print version</strong>
  <strong>-l, --list         : list actions</strong>
  <strong>-a, --all          : list hidden actions/options, too</strong>
  <strong>-v, --verbose      : verbose mode</strong>
  <strong>-q, --quiet        : quiet mode</strong>
  <strong>--color[=&lton|off&gt;] : enable/disable color mode</strong>
  <strong>-D, --debug        : set $DEBUG_MODE to true</strong>
  <strong>-T, --trace        : report enter into and exit from action</strong>

Actions:
  help               : print help message (of action if specified)
</pre>
</section>
<section class="subsection" id="customization-of-global-option-behaviour">
<h3>Customization of Global Option Behaviour</h3>
<ul>
<li>(1) Define subclass of <code>Application</code> class.</li>
<li>(2) Override <code>#toggle_global_options()</code> method.</li>
<li>(3) Create and execute subclass object of <code>Application</code>.</li>
</ul>
<p>File: ex34.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

## (1) Define subclass of ``Application`` class.
<strong>class MyApplication &lt Benry::CmdApp::Application</strong>

  ## (2) Override ``#toggle_global_options()`` method.
  <strong>def toggle_global_options(global_opts)</strong>
    <strong>status_code = super</strong>
    <strong>return status_code if status_code</strong>  # `return 0` means "stop process successfully",
                                       # `return 1` means "stop process as failed".
    if global_opts[:logging]
      require 'logger'
      $logger = Logger.new(STDOUT)
    end
    <strong>return nil</strong>                   # `return nil` means "continue process".
  end

end

## (3) Create and execute subclass object of ``Application``.
config = Benry::CmdApp::Config.new("sample app")
app = <strong>MyApplication.new(config)</strong>            # !!!!
exit app.main()
</pre>
<p>Of course, prepending custom module to Application class is also effective way.</p>
<p>File: ex35.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

<strong>module MyApplicationMod</strong>

  <strong>def toggle_global_options(global_opts)</strong>
    # ....
  end

end

Benry::CmdApp::Application<strong>.prepend(MyApplicationMod)</strong>   # !!!!

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
</section>
<section class="subsection" id="custom-hook-of-application">
<h3>Custom Hook of Application</h3>
<ul>
<li>(1) Define subclass of Application class.</li>
<li>(2) Override <code>#handle_action()</code> method.</li>
<li>(3) Create and execute custom application object.</li>
</ul>
<p>File: ex36.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("test action")
  def test1()
    $logger.info("logging message") if $logger
  end

end

## (1) Define subclass of Application class
<strong>class MyApplication &lt Benry::CmdApp::Application</strong>   # !!!!

  ## (2) Override method
  <strong>def handle_action(action, args)</strong>                  # !!!!
    #p @config
    $logger.debug("action=#{action}, args=#{args.inspect}") if $logger
    <strong>super</strong>                                          # !!!!
  end

end

## (3) create and execute custom application object
config = Benry::CmdApp::Config.new("sample app")
schema = Benry::CmdApp::GlobalOptionSchema.new(config)
schema.add(:logging, "--logging", "enable logging")
app = <strong>MyApplication</strong>.new(config, schema)             # !!!!
exit app.main()
</pre>
</section>
<section class="subsection" id="customization-of-application-help-message">
<h3>Customization of Application Help Message</h3>
<p>If you want to just add more text into application help message,
set <code>config.app_detail</code> and/or <code>config.help_postamble</code>.</p>
<p>File: ex38.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("test action #1")
  def hello(user="world")
    puts "Hello, #{user}!"
  end

end

config = Benry::CmdApp::Config.new("sample app")
<strong>config.app_detail = "See https://...."</strong>            # !!!!
<strong>config.help_postamble = [</strong>                         # !!!!
<strong>  {"Example:" =&gt; "  $ &ltcommand&gt; hello Alice\n"},</strong>  # !!!!
<strong>  "(Tips: ....)",</strong>                                 # !!!!
<strong>]</strong>                                                 # !!!!

app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Help message:</p>
<pre class="language-console">
[bash]$ ruby ex38.rb -h
ex38.rb --- sample app

<strong>See https://....</strong>

Usage:
  $ ex38.rb [&ltoptions&gt;] &ltaction&gt; [&ltarguments&gt;...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list hidden actions/options, too

Actions:
  hello              : test action #1

<strong>Example:</strong>
  <strong>$ &ltcommand&gt; hello Alice</strong>

<strong>(Tips: ....)</strong>
</pre>
<p>If you want to change behaviour of building command help message:</p>
<ul>
<li>(1) Define subclass of <code>Benry::CmdApp::ApplicationHelpBuilder</code> class.</li>
<li>(2) Override methods.</li>
<li>(3) Create an instance object of the class.</li>
<li>(4) Pass it to Application object.</li>
</ul>
<p>File: ex39.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("print greeting message")
  def hello(user="world")
    puts "Hello, #{user}!"
  end

end

## (1) Define subclass of ``Benry::CmdApp::ApplicationHelpBuilder`` class.
<strong>class MyAppHelpBuilder &lt Benry::CmdApp::ApplicationHelpBuilder</strong>

  ## (2) Override methods.
  def <strong>build_help_message</strong>(gschema, all: false)
    super
  end
  def <strong>build_preamble_part</strong>()
    super
  end
  def <strong>build_usage_part</strong>()
    super
  end
  def <strong>build_options_part</strong>(gschema, all: false)
    super
  end
  def <strong>build_actions_part</strong>(all: false, &amp;filter)
    super
  end
  def <strong>build_postamble_part</strong>()
    super
  end
end

## (3) Create an instance object of the class.
config = Benry::CmdApp::Config.new("sample app")
schema = Benry::CmdApp::GlobalOptionSchema.new(config)
schema.add(:logging, "--logging", "enable logging")
<strong>app_help_builder = MyAppHelpBuilder.new(config)</strong>      # !!!!

## (4) Pass it to Application object.
app = Benry::CmdApp::Application.new(config, schema, <strong>app_help_builder</strong>) # !!!!
exit app.main()
</pre>
<p>More simple way:</p>
<ul>
<li>(1) Create a module and override methods of <code>Benry::CmdApp::ApplicationHelpBuilder</code> class.</li>
<li>(2) Prepend it to <code>Benry::CmdApp::ApplicationHelpBuilder</code> class.</li>
<li>(3) Create and execute Application object.</li>
</ul>
<p>File: ex40.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("print greeting message")
  def hello(user="world")
    puts "Hello, #{user}!"
  end

end

## (1) Create a module and override methods of ``ApplicationHelpBuilder`` class.
<strong>module MyHelpBuilderMod</strong>
  def build_help_message(all=false, format=nil)
    super
  end
  def build_help_message(gschema, all: false)
    super
  end
  def build_preamble_part()
    super
  end
  def build_usage_part()
    super
  end
  def build_options_part(gschema, all: false)
    super
  end
  def build_actions_part(all: false)
    super
  end
  def build_postamble_part()
    super
  end
end

## (2) Prepend it to ``Benry::CmdApp::ApplicationHelpBuilder`` class.
<strong>Benry::CmdApp::ApplicationHelpBuilder.prepend(MyHelpBuilderMod)</strong>

## (3) Create and execute Application object.
config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
</section>
<section class="subsection" id="customization-of-action-help-message">
<h3>Customization of Action Help Message</h3>
<p>If you want to just add more text into action help message,
pass <code>detail:</code> and/or <code>postamble:</code> keyword arguments to <code>@action.()</code>.</p>
<p>File: ex41.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("test action #1",
           <strong>detail: "See https://...."</strong>,           # !!!!
           <strong>postamble: {"Example:" =&gt; "  ...."}</strong>)  # !!!!
  def hello(user="world")
    puts "Hello, #{user}!"
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Help message:</p>
<pre class="language-console">
[bash]$ ruby ex41.rb -h hello
ex41.rb hello --- test action #1

<strong>See https://....</strong>                  # !!!!

Usage:
  $ ex41.rb hello [&ltuser&gt;]

<strong>Example:</strong>
  <strong>....</strong>                            # !!!!
</pre>
<p>If you want to change behaviour of building action help message:</p>
<ul>
<li>(1) Define subclass of <code>ActionHelpBuilder</code> class.</li>
<li>(2) Override methods.</li>
<li>(3) Create an instance object of the class.</li>
<li>(4) Pass it to Application object.</li>
</ul>
<p>File: ex42.rb</p>
<pre class="language-ruby">
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("print greeting message")
  def hello(user="world")
    puts "Hello, #{user}!"
  end

end

## (1) Define subclass of ``ActionHelpBuilder`` class.
<strong>class MyActionHelpBuilder &lt Benry::CmdApp::ActionHelpBuilder</strong>
  ## (2) Override methods.
  def <strong>build_help_message</strong>(metadata, all: false)
    super
  end
  def <strong>build_preamble_part</strong>(metadata)
    super
  end
  def <strong>build_usage_part</strong>(metadata, all: false)
    super
  end
  def <strong>build_options_part</strong>(metadata, all: false)
    super
  end
  def <strong>build_postamble_part</strong>(metadata)
    super
  end
end

## (3) Create an instance object of the class.
config = Benry::CmdApp::Config.new("sample app")
<strong>action_help_builder = MyActionHelpBuilder.new(config)</strong>

## (4) Pass it to Application object.
schema = Benry::CmdApp::GlobalOptionSchema.new(config)
app = Benry::CmdApp::Application.new(config, schema, nil, <strong>action_help_builder</strong>)
exit app.main()
</pre>
<p>Another way:</p>
<ul>
<li>(1) Create a module and override methods of <code>Benry::CmdApp::ActionHelpBuilder</code> class.</li>
<li>(2) Prepend it to <code>Benry::CmdApp::ActionHelpBuilder</code> class.</li>
<li>(3) Create and execute Application object.</li>
</ul>
<p>File: ex43.rb</p>
<pre class="language-ruby">
# coding: utf-8
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("print greeting message")
  def hello(user="world")
    puts "Hello, #{user}!"
  end

end

## (1) Create a module and override methods of ``ActionHelpBuilder`` class.
<strong>module MyActionHelpBuilderMod</strong>
  def <strong>build_help_message</strong>(metadata, all: false)
    super
  end
  def <strong>build_preamble_part</strong>(metadata)
    super
  end
  def <strong>build_usage_part</strong>(metadata, all: false)
    super
  end
  def <strong>build_options_part</strong>(metadata, all: false)
    super
  end
  def <strong>build_postamble_part</strong>(metadata)
    super
  end
end

## (2) Prepend it to ``Benry::CmdApp::ActionHelpBuilder`` class.
Benry::CmdApp::ActionHelpBuilder<strong>.prepend(MyActionHelpBuilderMod)</strong>  # !!!!

## (3) Create and execute Application object.
config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
</section>
</section>
<section class="section" id="q--a">
<h2>Q &amp; A</h2>
<section class="subsection" id="q-how-to-append-some-tasks-to-an-existing-action">
<h3>Q: How to append some tasks to an existing action?</h3>
<p>A: (a) Use method alias, or (b) use prepend.</p>
<p>File: ex51.rb</p>
<pre class="language-ruby">
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("test action #1")
  def <strong>hello</strong>(user="world")
    puts "Hello, #{user}!"
  end

  @action.("test action #2")
  def <strong>hi</strong>(user="world")
    puts "Hi, #{user}!"
  end

end

## (a) use method alias
class SampleAction               # open existing class
  <strong>alias __old_hello hello</strong>        # alias of existing method
  def <strong>hello</strong>(user="world")        # override existing method
    puts "---- &gt;8 ---- &gt;8 ----"
    <strong>__old_hello(user)</strong>            # call original method
    puts "---- 8&lt ---- 8&lt ----"
  end
end

## (b) use prepend
<strong>module SampleMod</strong>                 # define new module
  def <strong>hi</strong>(user="world")           # override existing method
    puts "~~~~ &gt;8 ~~~~ &gt;8 ~~~~"
    <strong>super</strong>                        # call original method
    puts "~~~~ 8&lt ~~~~ 8&lt ~~~~"
  end
end
SampleAction<strong>.prepend(SampleMod)</strong>  # prepend it to existing class

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex51.rb hello
---- &gt;8 ---- &gt;8 ----
Hello, world!
---- 8&lt ---- 8&lt ----

[bash]$ ruby ex51.rb hi Alice
~~~~ &gt;8 ~~~~ &gt;8 ~~~~
Hi, Alice!
~~~~ 8&lt ~~~~ 8&lt ~~~~
</pre>
</section>
<section class="subsection" id="q-how-to-delete-an-existing-actionalias">
<h3>Q: How to delete an existing action/alias?</h3>
<p>A: Call <code>Benry::CmdApp.undef_action("&ltaction&gt;")</code> or <code>Benry::CmdApp.undef_alias("&ltalias&gt;")</code>.</p>
</section>
<section class="subsection" id="q-how-to-re-define-an-existing-action">
<h3>Q: How to re-define an existing action?</h3>
<p>A: First remove the existing action, then re-define the action.</p>
<p>File: ex52.rb</p>
<pre class="language-ruby">
require 'benry/cmdapp'

class <strong>SampleAction</strong> &lt Benry::CmdApp::Action

  @action.("sample action")
  def <strong>hello</strong>()                               # !!!!
    puts "Hello, world!"
  end

end

Benry::CmdApp<strong>.undef_action("hello")</strong>        # !!!!

class <strong>OtherAction</strong> &lt Benry::CmdApp::Action

  @action.("other action")                  # !!!!
  def <strong>hello</strong>()                               # !!!!
    puts "Ciao, world!"
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Help message:</p>
<pre class="language-console">
[bash]$ ruby ex52.rb -h
ex52.rb --- sample app

Usage:
  $ ex52.rb [&ltoptions&gt;] &ltaction&gt; [&ltarguments&gt;...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list hidden actions/options, too

Actions:
  <strong>hello              : other action</strong>       # !!!!
  help               : print help message (of action if specified)
</pre>
</section>
<section class="subsection" id="q-how-to-show-entering-into-or-exitting-from-actions">
<h3>Q: How to show entering into or exitting from actions?</h3>
<p>A: Set <code>config.option_trace = true</code> and pass <code>-T</code> (or <code>--trace</code>) option.</p>
<p>File: ex53.rb</p>
<pre class="language-ruby">
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("preparation")
  def prepare()
    puts "... prepare something ..."
  end

  @action.("build")
  def build()
    run_once("prepare")
    puts "... build something ..."
  end

end

config = Benry::CmdApp::Config.new("sample app")
<strong>config.option_trace = true</strong>                      # !!!! (or `:hidden`)
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex53.rb <strong>--trace</strong> build              # !!!!
<strong>### enter: build</strong>
<strong>### enter: prepare</strong>
... prepare something ...
<strong>### exit:  prepare</strong>
... build something ...
<strong>### exit:  build</strong>
</pre>
</section>
<section class="subsection" id="q-how-to-enabledisable-color-mode">
<h3>Q: How to enable/disable color mode?</h3>
<p>A: Set <code>config.option_color = true</code> and pass <code>--color=on</code> or <code>--color=off</code> option.</p>
<p>File: ex54.rb</p>
<pre class="language-ruby">
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("print greeting message")
  def hello(user="world")
    puts "Hello, #{user}!"
  end

end

config = Benry::CmdApp::Config.new("sample app")
<strong>config.option_color = true</strong>                       # !!!!
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Help message:</p>
<pre class="language-console">
[bash]$ ruby ex54.rb -h
ex54.rb --- sample app

Usage:
  $ ex54.rb [&ltoptions&gt;] &ltaction&gt; [&ltarguments&gt;...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list hidden actions/options, too
  <strong>--color[=&lton|off&gt;] : enable/disable color</strong>      # !!!!

Actions:
  hello              : print greeting message

[bash]$ ruby ex54.rb -h <strong>--color=off</strong>              # !!!!

[bash]$ ruby ex54.rb -h <strong>--color=on</strong>               # !!!!
[bash]$ ruby ex54.rb -h <strong>--color</strong>                  # !!!!
</pre>
</section>
<section class="subsection" id="q-how-to-define-a-multiple-option-like--i-option-of-ruby">
<h3>Q: How to define a multiple option, like <code>-I</code> option of Ruby?</h3>
<p>A: Provide block parameter on <code>@option.()</code>.</p>
<p>File: ex55.rb</p>
<pre class="language-ruby">
require 'benry/cmdapp'

class TestAction &lt Benry::CmdApp::Action

  @action.("multiple option test")
  @option.(:path, "-I &ltpath&gt;", "path") <strong>{|options, key, val|</strong>  # !!!!
    <strong>arr = options[key] || []</strong>                                 # !!!!
    <strong>arr &lt&lt val</strong>                                               # !!!!
    <strong>arr</strong>                                                      # !!!!
    ## or:                                                   # !!!!
    #<strong>(options[key] || []) &lt&lt val</strong>                             # !!!!
  <strong>}</strong>                                                          # !!!!
  def test_(path: [])
    puts "path=#{path.inspect}"     #=&gt; path=["/tmp", "/var/tmp"]
  end

end

config = Benry::CmdApp::Config.new("test app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Output:</p>
<pre class="language-console">
[bash]$ ruby ex55.rb test <strong>-I /tmp -I /var/tmp</strong>     # !!!!
path=["/tmp", "/var/tmp"]                         # !!!!
</pre>
</section>
<section class="subsection" id="q-how-to-show-global-option--l-topic-in-help-message">
<h3>Q: How to show global option <code>-L &lttopic&gt;</code> in help message?</h3>
<p>A: Set <code>config.option_topic = true</code> (default: <code>:hidden</code>).</p>
</section>
<section class="subsection" id="q-how-to-specify-detailed-description-of-options">
<h3>Q: How to specify detailed description of options?</h3>
<p>A: Add <code>detail:</code> keyword argument to <code>@option.()</code>.</p>
<p>File: ex56.rb</p>
<pre class="language-ruby">
require 'benry/cmdapp'

class TestAction &lt Benry::CmdApp::Action

  @action.("detailed description test")
  @option.(:mode, "-m &ltmode&gt;", "output mode", <strong>detail:</strong> &lt&lt"END")
   v, verbose: print many output
   q, quiet:   print litte output
   c, compact: print summary output
END
  def test_(mode: nil)
    puts "mode=#{mode.inspect}"
  end

end

config = Benry::CmdApp::Config.new("test app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Help message:</p>
<pre class="language-console">
[bash]$ ruby ex56.rb -h test
ex56.rb test --- detailed description test

Usage:
  $ ex56.rb test [&ltoptions&gt;]

Options:
  -m &ltmode&gt;          : output mode
                          <strong>v, verbose: print many output</strong>
                          <strong>q, quiet:   print litte output</strong>
                          <strong>c, compact: print summary output</strong>
</pre>
</section>
<section class="subsection" id="q-how-to-copy-all-options-from-other-action">
<h3>Q: How to copy all options from other action?</h3>
<p>A: Use <code>@copy_options.()</code>.</p>
<p>File: ex57.rb</p>
<pre class="language-ruby">
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("test action #1")
  @option.(:verbose, "-v, --verbose", "verbose mode")
  @option.(:file, "-f, --file=&ltfile&gt;", "filename")
  @option.(:indent, "-i, --indent[=&ltN&gt;]", "indent")
  def test1(verbose: false, file: nil, indent: nil)
    puts "verbose=#{verbose}, file=#{file}, indent=#{indent}"
  end

  @action.("test action #2")
  <strong>@copy_options.("test1")</strong>         # !!!! copy options from test1 !!!!
  @option.(:debug, "-D, --debug", "debug mode")
  def test2(verbose: false, file: nil, indent: nil, debug: false)
    puts "verbose=#{verbose}, file=#{file}, indent=#{indent}, debug=#{debug}"
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Help message of <code>test2</code> action:</p>
<pre class="language-console">
[bash]$ ruby ex57.rb -h test2
ex57.rb test2 --- test action #2

Usage:
  $ ex57.rb test2 [&ltoptions&gt;]

Options:
  -v, --verbose      : verbose mode     # copied!!
  -f, --file=&ltfile&gt;  : filename         # copied!!
  -i, --indent[=&ltN&gt;] : indent           # copied!!
  -D, --debug        : debug mode
</pre>
<p>If you want to exclude some options from copying, specify <code>exlude:</code> keyword argument.
For example, <code>@copy_options.("hello", exclude: [:help, :lang])</code> copies all options of <code>hello</code> action excluding <code>:help</code> and <code>:lang</code> options.</p>
</section>
<section class="subsection" id="q-what-is-the-difference-between-prefixalias_of-and-prefixaction">
<h3>Q: What is the difference between <code>prefix(alias_of:)</code> and <code>prefix(action:)</code>?</h3>
<p>A: The former defines an alias, and the latter doesn't.</p>
<p>File: ex58.rb</p>
<pre class="language-ruby">
require 'benry/cmdapp'

class AaaAction &lt Benry::CmdApp::Action
  prefix "aaa:", <strong>alias_of:</strong> "print"

  @action.("test #1")
  def print_()
    puts "test"
  end

end

class BbbAction &lt Benry::CmdApp::Action
  prefix "bbb:", <strong>action:</strong> "print"

  @action.("test #2")
  def print_()
    puts "test"
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
<p>Help message:</p>
<pre class="language-console">
[bash]$ ruby ex58.rb -h
ex58.rb --- sample app

Usage:
  $ ex58.rb [&ltoptions&gt;] &ltaction&gt; [&ltarguments&gt;...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -L &lttopic&gt;         : list of a topic (action|alias|prefix|abbrev)
  -a, --all          : list hidden actions/options, too

Actions:
  <strong>aaa                : alias of 'aaa:print' action</strong>    # !!!!
  aaa:print          : test #1
  <strong>bbb                : test #2</strong>                        # !!!!
  help               : print help message (of action if specified)
</pre>
<p>In the above example, alias <code>aaa</code> is defined due to <code>prefix(alias_of:)</code>,
and action <code>bbb</code> is not an alias due to <code>prefix(action:)</code>.</p>
</section>
<section class="subsection" id="q-how-to-list-only-aliases-or-actions-excluding-actions-or-aliases-">
<h3>Q: How to list only aliases (or actions) excluding actions (or aliases) ?</h3>
<p>A: Specify global option <code>-L alias</code> or <code>-L action</code>.</p>
<pre class="language-console">
[bash]$ ruby gitexample.rb -l
Actions:
  git                : alias of 'git:status'
  git:stage          : put changes of files into staging area
  git:staged         : show changes in staging area
  git:status         : show status in compact format
  git:unstage        : remove changes from staging area
  stage              : alias of 'git:stage'
  staged             : alias of 'git:staged'
  unstage            : alias of 'git:unstage'

### list only aliases
[bash]$ ruby gitexample.rb <strong>-L alias</strong>     # !!!!
Aliases:
  git                : alias of 'git:status'
  stage              : alias of 'git:stage'
  staged             : alias of 'git:staged'
  unstage            : alias of 'git:unstage'

### list only actions
[bash]$ ruby gitexample.rb <strong>-L action</strong>     # !!!!
Actions:
  git:stage          : put changes of files into staging area
  git:staged         : show changes in staging area
  git:status         : show status in compact format
  git:unstage        : remove changes from staging area
</pre>
</section>
<section class="subsection" id="q-how-to-change-the-order-of-options-in-help-message">
<h3>Q: How to change the order of options in help message?</h3>
<p>A: Call <code>GlobalOptionSchema#reorder_options!()</code>.</p>
<p>File: ex59.rb</p>
<pre class="language-ruby">
require 'benry/cmdapp'

config = Benry::CmdApp::Config.new("sample app", "1.0.0",
  option_verbose:   true,
  option_quiet:     true,
  option_color:     true,
)
schema = Benry::CmdApp::GlobalOptionSchema.new(config)
<strong>keys = [:verbose, :quiet, :color, :help, :version, :all, :target, :list]</strong>  # !!!!
<strong>schema.reorder_options!(*keys)</strong>               # !!!!
app = Benry::CmdApp::Application.new(config, schema)
## or:
#app = Benry::CmdApp::Application.new(config)
#<strong>app.schema.reorder_options!(*keys)</strong>          # !!!!
exit app.main()
</pre>
<p>Help message:</p>
<pre class="language-console">
[bash]$ ruby ex59.rb -h
ex59.rb (1.0.0) --- sample app

Usage:
  $ ex59.rb [&ltoptions&gt;] &ltaction&gt; [&ltarguments&gt;...]

Options:
  -v, --verbose      : verbose mode
  -q, --quiet        : quiet mode
  --color[=&lton|off&gt;] : color mode
  -h, --help         : print help message (of action if specified)
  -V, --version      : print version
  -a, --all          : list hidden actions/options, too
  -L &lttopic&gt;         : list of a topic (action|alias|prefix|abbrev)
  -l, --list         : list actions

Actions:
  help               : print help message (of action if specified)
</pre>
</section>
<section class="subsection" id="q-is-it-possible-to-add-metadata-to-actions-or-options">
<h3>Q: Is it possible to add metadata to actions or options?</h3>
<p>A: Yes. Pass <code>tag:</code> keyword argument to <code>@action.()</code> or <code>@option.()</code>.</p>
<ul>
<li><code>tag:</code> keyword argument accept any type of value such as symbol, string, array, and so on.</li>
<li>Currenty, Benry-CmdApp doesn't provide the good way to use it effectively.
  This feature may be used by command-line application or framework based on Benry-CmdApp.</li>
</ul>
<p>File: ex60.rb</p>
<pre class="language-ruby">
require 'benry/cmdapp'

class SampleAction &lt Benry::CmdApp::Action

  @action.("print greeting message", <strong>tag: :important</strong>)            # !!!!
  @option.(:repeat, "-r &ltN&gt;", "repeat N times", <strong>tag: :important</strong>) # !!!!
  def hello(user="world", repeat: nil)
    (repeat || 1).times do
      puts "Hello, #{user}!"
    end
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
</pre>
</section>
<section class="subsection" id="how-to-remove-common-help-option-from-all-actions">
<h3>How to remove common help option from all actions?</h3>
<p>A: Clears `Benry::CmdApp::ACTION_SHARED_OPTIONS` which is an array of option item.</p>
<p>File: ex61.rb</p>
<pre class="language-ruby">
require 'benry/cmdapp'

arr = <strong>Benry::CmdApp::ACTION_SHARED_OPTIONS</strong>
arr.clear()
</pre>
</section>
<section class="subsection" id="q-how-to-make-error-messages-i18ned">
<h3>Q: How to make error messages I18Ned?</h3>
<p>A: Currently not supported. May be supported in a future release.</p>
</section>
</section>
<section class="section" id="license-and-copyright">
<h2>License and Copyright</h2>
<ul>
<li>$License: MIT License $</li>
<li>$Copyright: copyright(c) 2023 kwatch@gmail.com $</li>
</ul>
</section>
</section>
</main>
</body>
</html>
