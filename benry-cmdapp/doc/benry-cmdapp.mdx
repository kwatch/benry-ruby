= Benry-CmdApp

($Release: 0.0.0 $)


== What's This?

Benry-CmdApp is a framework to create command-line application.
If you want create command-line application which takes sub-commands
like ``git``, ``docker``, or ``npm``, Benry-CmdApp is the solution.

Base idea:

* Sub-command (= action) is defined as a method in Ruby.
* Commnad-line arguments are passed to action method as positional arguments.
* Command-line options are passed to action method as keyword arguments.

For example:

* ``<command> foo`` in command-line invokes action method ``foo()`` in Ruby.
* ``<command> foo arg1 arg2`` invokes ``foo("arg1", "arg2")``.
* ``<command> foo arg --opt=val`` invokes ``foo("arg", opt: "val")``.

Links:

* Document: <https://kwatch.github.io/benry-ruby/benry-cmdapp.html>
* GitHub: <https://github.com/kwatch/benry-ruby/tree/main/benry-cmdapp>
* Changes: <https://github.com/kwatch/benry-ruby/tree/main/benry-cmdapp/CHANGES.md>

Benry-CmdApp requires Ruby >= 2.3.


=== Table of Contents

<!-- TOC/ -->



== Install

```console
$ gem install benry-cmdapp
```



== Usage


=== Action

* Inherit action class and define action methods in it.
* An action class can have several action methods.
* It is ok to define multiple action classes.
* Command-line arguments are passed to action method as positional arguments.

File: ex01.rb

```ruby
# coding: utf-8
{{*require 'benry/cmdapp'*}}

## action
class MyAction < {{*Benry::CmdApp::Action*}}    # !!!!

  {{*@action.("print greeting message")*}}      # !!!!
  {{*def hello(user="world")*}}                 # !!!!
    puts "Hello, #{user}!"
  end

end

## configuration
config = {{*Benry::CmdApp::Config.new("sample app", "1.0.0")*}}

## run application
app = {{*Benry::CmdApp::Application.new(config)*}}
status_code = app.main()
exit status_code
```

Output:

```console
[bash]$ ruby ex01.rb {{*hello*}}           # action
Hello, world!

[bash]$ ruby ex01.rb {{*hello Alice*}}     # action + argument
Hello, {{*Alice*}}!
```

Help message of command:

```console
[bash]$ ruby ex01.rb {{*-h*}}     # or `{{*--help*}}`
ex01.rb (1.0.0) --- sample app

Usage:
  $ ex01.rb [<options>] <action> [<arguments>...]

Options:
  -h, --help         : print help message (of action if specified)
  -V, --version      : print version
  -l, --list         : list actions
  -a, --all          : list all actions/options including hidden ones

Actions:
  hello              : print greeting message
  help               : print help message (of action if specified)
```

Help message of action:

```console
[bash]$ ruby ex01.rb {{*-h hello*}}     # or: ruby ex01.rb help hello
ex01.rb hello --- print greeting message

Usage:
  $ ex01.rb hello [<user>]
```


=== Method Name and Action Name

* Method name ``print_`` results in action name ``print``.
  This is useful to define actions which name is same as Ruby keyword or popular functions.
* Method name ``foo_bar_baz`` results in action name ``foo-bar-baz``.
* Method name ``foo__bar__baz`` results in action name ``foo:bar:baz``.

File: ex02.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  ## 'print_' => 'print'
  @action.("sample #1")
  def print{{*_*}}()                 # !!!!
    puts __method__
  end

  ## 'foo_bar_baz' => 'foo-bar-baz'
  @action.("sample #2")
  def foo{{*_*}}bar{{*_*}}baz()            # !!!!
    puts __method__
  end

  ## 'foo__bar__baz' => 'foo:bar:baz'
  @action.("sample #3")
  def foo{{*__*}}bar{{*__*}}baz()          # !!!!
    puts __method__
  end

end

config = Benry::CmdApp::Config.new("test app")
app = Benry::CmdApp::Application.new(config)
status_code = app.main()
exit status_code
```

Help message:

```console
[bash]$ ruby ex02.rb --help
ex02.rb --- test app

Usage:
  $ ex02.rb [<options>] <action> [<arguments>...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list all actions/options including hidden ones

Actions:
  {{*foo-bar-baz*}}        : sample #2
  {{*foo:bar:baz*}}        : sample #3
  help               : print help message (of action if specified)
  {{*print*}}              : sample #1
```

Output:

```console
[bash]$ ruby ex02.rb {{*print*}}            # `print_` method
print_

[bash]$ ruby ex02.rb {{*foo-bar-baz*}}      # `foo_bar_baz` method
foo_bar_baz

[bash]$ ruby ex02.rb {{*foo:bar:baz*}}      # `foo__bar__baz` method
foo__bar__baz
```


=== Parameter Name in Help Message of Action

In help message of an action, positional parameters of action methods are printed under the name conversion rule.

* Parameter ``foo`` is printed as ``<foo>``.
* Parameter ``foo_bar_baz`` is printed as ``<foo-bar-baz>``.
* Parameter ``foo_or_bar_or_baz`` is printed as ``<foo|bar|baz>``.
* Parameter ``foobar__xxx`` is printed as ``<foobar.xxx>``.

In addition, positional parameters are printed in different way according to its kind.

* If parameter ``foo`` is required (= doesn't have default value), it will be printed as ``<foo>``.
* If parameter ``foo`` is optional (= has default value), it will be printed as ``[<foo>]``.
* If parameter ``foo`` is variable length (= ``*foo`` style), it will be printed as ``[<foo>...]``.


File: ex03.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("name conversion test")
  def test1({{*file_name, file_or_dir, file__html*}})  # !!!!
    # ...
  end

  @action.("parameter kind test")
  def test2({{*aaa, bbb, ccc=nil, ddd=nil, *eee*}})  # !!!!
    # ...
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
status_code = app.main()
exit status_code
```

Help message:

```console
[bash]$ ruby ex03.rb -h test1
ex03.rb test1 --- name conversion test

Usage:
  $ ex03.rb test1 {{*<file-name> <file|dir> <file.html>*}}  # !!!!

[bash]$ ruby ex03.rb -h test2
ex03.rb test2 --- parameter kind test

Usage:
  $ ex03.rb test2 {{*<aaa> <bbb> [<ccc> [<ddd> [<eee>...]]]*}}    # !!!!
```


=== Options

* Action can take command-line options.
* Option values specified in command-line are passed to actio method as keyword arguments.

File: ex04.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class MyAction < Benry::CmdApp::Action

  @action.("print greeting message")
  {{*@option.(:lang, "-l, --lang=<en|fr|it>", "language")*}}   # !!!!
  def hello(user="world", {{*lang: "en"*}})                    # !!!!
    case lang
    when "en" ; puts "Hello, #{user}!"
    when "fr" ; puts "Bonjour, #{user}!"
    when "it" ; puts "Ciao, #{user}!"
    else
      raise "#{lang}: unknown language."
    end
  end

end

config = Benry::CmdApp::Config.new("sample app", "1.0.0")
app = Benry::CmdApp::Application.new(config)
status_code = app.main()
exit status_code
```

Output:

```console
[bash]$ ruby ex04.rb hello
{{*Hello*}}, world!

[bash]$ ruby ex04.rb hello {{*-l fr*}}            # !!!!
{{*Bonjour*}}, world!

[bash]$ ruby ex04.rb hello {{*--lang=it*}}        # !!!!
{{*Ciao*}}, world!
```

* An action can have multiple options.
* Option format can have indentation spaces, for example ``'    --help'``.

File: ex05.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class MyAction < Benry::CmdApp::Action

  @action.("print greeting message")
  @option.(:lang  , "-l, --lang=<en|fr|it>", "language")
  {{*@option.(:repeat, "    --repeat=<N>", "repeat <N> times")*}}  # !!!!
  def hello(user="world", lang: "en", {{*repeat: "1"*}})
    #p repeat.class   #=> String                    # !!!!
    repeat.to_i.times do                            # !!!!
      case lang
      when "en" ; puts "Hello, #{user}!"
      when "fr" ; puts "Bonjour, #{user}!"
      when "it" ; puts "Ciao, #{user}!"
      else
        raise "#{lang}: unknown language."
      end
    end
  end

end

config = Benry::CmdApp::Config.new("sample app", "1.0.0")
app = Benry::CmdApp::Application.new(config)
status_code = app.main()
exit status_code
```

Output:

```console
[bash]$ ruby ex05.rb hello Alice -l fr {{*--repeat=3*}}
Bonjour, Alice!
Bonjour, Alice!
Bonjour, Alice!
```

Help message:

```console
[bash]$ ruby ex05.rb -h hello
ex05.rb hello --- print greeting message

Usage:
  $ ex05.rb hello [<options>] [<user>]

Options:
  -l, --lang=<en|fr|it> : language        # !!!!
  {{*    --repeat=<N>   : repeat <N> times*}}   # !!!!
```

For usability reason, Benry::CmdApp supports ``--lang=<val>`` style of long option
but doesn't support ``--lang <val>`` style.
Benry::CmdApp regards ``--lang <val>`` as 'long option without argument'
and 'argument for command'.

```console
[bash]$ ruby ex05.rb hello {{*--lang fr*}}         # ``--lang fr`` != ``--lang=fr``
{{*[ERROR] --lang: argument required.*}}
```


=== Option Definition Format

Option definition format should be one of:

* (short option) ``-q``  : no values.
* (short option) ``-f <file>`` : value required.
* (short option) ``-i[<width>]`` : value is optional.
* (long option) ``--quiet``  : no values.
* (long option) ``--file=<file>`` : value required.
* (long option) ``--indent[=<width>]`` : value is optional.
* (short & long) ``-q, --quiet``  : no values.
* (short & long) ``-f, --file=<file>`` : value required.
* (short & long) ``-i, --indent[=<width>]`` : value is optional.

File: ex06.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  ## short options
  @action.("short options")
  @option.(:quiet  , {{*"-q"*}}        , "quiet mode")     # none
  @option.(:file   , {{*"-f <file>"*}} , "filename")       # required
  @option.(:indent , {{*"-i[<N>]"*}}   , "indent width")   # optional
  def test1(quiet: false, file: nil, indent: nil)
    puts "quiet=#{quiet.inspect}, file=#{file.inspect}, indent=#{indent.inspect}"
  end

  ## long options
  @action.("long options")
  @option.(:quiet  , {{*"--quiet"*}}        , "quiet mode")     # none
  @option.(:file   , {{*"--file=<file>"*}}  , "filename")       # required
  @option.(:indent , {{*"--indent[=<N>]"*}} , "indent width")   # optional
  def test2(quiet: false, file: nil, indent: nil)
    puts "quiet=#{quiet.inspect}, file=#{file.inspect}, indent=#{indent.inspect}"
  end

  ## short and long options
  @action.("short and long options")
  @option.(:quiet  , {{*"-q, --quiet"*}}        , "quiet mode")    # none
  @option.(:file   , {{*"-f, --file=<file>"*}}  , "filename")      # required
  @option.(:indent , {{*"-i, --indent[=<N>]"*}} , "indent width")  # optional
  def test3(quiet: false, file: nil, indent: nil)
    puts "quiet=#{quiet.inspect}, file=#{file.inspect}, indent=#{indent.inspect}"
  end

end

config = Benry::CmdApp::Config.new("test app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Output:

```console
[bash]$ ruby ex06.rb test1 {{*-q -f readme.txt -i4*}}
quiet=true, file="readme.txt", indent="4"

[bash]$ ruby ex06.rb test2 {{*--quiet --file=readme.txt --indent=4*}}
quiet=true, file="readme.txt", indent="4"

[bash]$ ruby ex06.rb test3 {{*-q -f readme.txt -i4*}}
quiet=true, file="readme.txt", indent="4"
[bash]$ ruby ex06.rb test3 {{*--quiet --file=readme.txt --indent=4*}}
quiet=true, file="readme.txt", indent="4"
```

Optional argument example:

```console
[bash]$ ruby ex06.rb test1 {{*-i*}}                 # ``-i`` results in ``true``
quiet=false, file=nil, {{*indent=true*}}
[bash]$ ruby ex06.rb test1 {{*-i4*}}                # ``-i4`` results in ``4``
quiet=false, file=nil, {{*indent="4"*}}

[bash]$ ruby ex06.rb test2 {{*--indent*}}           # ``--indent`` results in ``true``
quiet=false, file=nil, {{*indent=true*}}
[bash]$ ruby ex06.rb test2 {{*--indent=4*}}         # ``--indent=4`` results in ``4``
quiet=false, file=nil, {{*indent="4"*}}
```

Help message:

```ruby
[bash]$ ruby ex06.rb -h test1
ex06.rb test1 --- short options

Usage:
  $ ex06.rb test1 [<options>]

Options:
  {{*-q*}}                 : quiet mode
  {{*-f <file>*}}          : filename
  {{*-i[<N>]*}}            : indent width

[bash]$ ruby ex06.rb -h test2
ex06.rb test2 --- long options

Usage:
  $ ex06.rb test2 [<options>]

Options:
  {{*--quiet*}}            : quiet mode
  {{*--file=<file>*}}      : filename
  {{*--indent[=<N>]*}}     : indent width

[bash]$ ruby ex06.rb -h test3
ex06.rb test3 --- short and long options

Usage:
  $ ex06.rb test3 [<options>]

Options:
  {{*-q, --quiet*}}        : quiet mode
  {{*-f, --file=<file>*}}  : filename
  {{*-i, --indent[=<N>]*}} : indent width
```


=== Option Value Validation

``@option.()`` can validate option value via keyword argument.

* ``type: <class>`` specifies option value class.
  Currently supports ``Integer``, ``Float``, ``TrueClass``, and ``Date``.
* ``rexp: <rexp>`` specifies regular expression of option value.
* ``enum: <array>`` specifies available values as option value.
* ``range: <range>`` specifies range of option value.

File: ex07.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class MyAction < Benry::CmdApp::Action

  @action.("print greeting message")
  @option.(:lang  , "-l, --lang=<en|fr|it>", "language",
                  {{*enum: ["en", "fr", "it"]*}},         # !!!!
		  {{*rexp: /\A\w\w\z/*}})                 # !!!!
  @option.(:repeat, "    --repeat=<N>", "repeat <N> times",
                  {{*type: Integer, range: 1..10*}})      # !!!!
  def hello(user="world", lang: "en", repeat: 1)
    #p repeat.class   #=> Integer
    repeat.times do
      case lang
      when "en" ; puts "Hello, #{user}!"
      when "fr" ; puts "Bonjour, #{user}!"
      when "it" ; puts "Ciao, #{user}!"
      else
        raise "#{lang}: unknown language."
      end
    end
  end

end

config = Benry::CmdApp::Config.new("sample app", "1.0.0")
app = Benry::CmdApp::Application.new(config)
status_code = app.main()
exit status_code
```

Output:

```console
[bash]$ ruby ex07.rb hello {{*-l japan*}}
{{*[ERROR] -l japan: Pattern unmatched.*}}

[bash]$ ruby ex07.rb hello {{*-l ja*}}
{{*[ERROR] -l ja: Expected one of en/fr/it.*}}

[bash]$ ruby ex07.rb hello {{*--repeat=abc*}}
{{*[ERROR] --repeat=abc: Integer expected.*}}

[bash]$ ruby ex07.rb hello {{*--repeat=100*}}
{{*[ERROR] --repeat=100: Too large (max: 10).*}}
```


=== Callback for Option Value

``@option.()`` can take a block argument which is a callback for option value.
Callback can:

* Do custom validation of option value.
* Convert option value into other value.

File: ex08.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class MyAction < Benry::CmdApp::Action

  @action.("print greeting message")
  @option.(:lang  , "-l, --lang=<en|fr|it>", "language",
                  enum: ["en", "fr", "it", "EN", "FR", "IT"],
		  rexp: /\A\w\w\z/) {{*{|v| v.downcase }*}}    # !!!!
  @option.(:repeat, "    --repeat=<N>", "repeat <N> times",
                  type: Integer) {{*{|v|*}}                    # !!!!
		    {{*v > 0 or raise "Not positive value."*}} # !!!!
                    {{*v*}}                                    # !!!!
                  {{*}*}}                                      # !!!!
  def hello(user="world", lang: "en", repeat: 1)
    repeat.times do
      case lang
      when "en" ; puts "Hello, #{user}!"
      when "fr" ; puts "Bonjour, #{user}!"
      when "it" ; puts "Ciao, #{user}!"
      else
        raise "#{lang}: unknown language."
      end
    end
  end

end

config = Benry::CmdApp::Config.new("sample app", "1.0.0")
app = Benry::CmdApp::Application.new(config)
status_code = app.main()
exit status_code
```

Output:

```console
[bash]$ ruby ex08.rb hello {{*-l FR*}}   # converted into lowercase
Bonjour, world!

[bash]$ ruby ex08.rb hello {{*--repeat=0*}}
{{*[ERROR] --repeat=0: Not positive value.*}}
```


=== Boolean (On/Off) Option

Benry::CmdApp doesn't support ``--[no-]foobar`` style option.
Instead, define boolean (on/off) option.

* Specify ``type: TrueClass`` to ``@option.()``.
* Option value ``true``, ``yes``, and ``on`` are converted into true.
* Option value ``false``, ``no``, and ``off`` are converted into false.

File: ex09.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("flag test")
  @option.(:verbose, {{*"--verbose[=<on|off>]"*}},  # !!!!
                     "verbose mode",
                     {{*type: TrueClass*}})         # !!!!
  def flagtest({{*verbose: false*}})                # !!!!
    puts "verbose=#{verbose}"
  end

end

config = Benry::CmdApp::Config.new("sample app", "1.0.0")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Output:

```console
[bash]$ ruby ex09.rb flagtest --verbose={{*on*}}       # on
verbose={{*true*}}

[bash]$ ruby ex09.rb flagtest --verbose={{*off*}}      # off
verbose={{*false*}}

[bash]$ ruby ex09.rb flagtest --verbose={{*true*}}     # on
verbose={{*true*}}

[bash]$ ruby ex09.rb flagtest --verbose={{*false*}}    # off
verbose={{*false*}}

[bash]$ ruby ex09.rb flagtest --verbose={{*yes*}}      # on
verbose={{*true*}}

[bash]$ ruby ex09.rb flagtest --verbose={{*no*}}       # off
verbose={{*false*}}

[bash]$ ruby ex09.rb flagtest --verbose={{*abc*}}      # error
{{*[ERROR] --verbose=abc: boolean expected.*}}
```

If you want default value of flag to ``true``, use ``value:`` keyword argument.

* ``value:`` keyword argument in ``@option.()`` specifies the substitute value
  instead of ``true`` when no option value specified in command-line.

File: ex10.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("flag test")
  @option.(:verbose, "-q, --quiet", "quiet mode",
                     {{*value: false*}})                 # !!!!
  def flagtest2({{*verbose: true*}})                     # !!!!
    puts "verbose=#{verbose.inspect}"
  end

end

config = Benry::CmdApp::Config.new("git helper")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Output:

```console
[bash]$ ruby ex10.rb flagtest2           # true if '--quiet' NOT specified
verbose={{*true*}}

[bash]$ ruby ex10.rb flagtest2 {{*--quiet*}}   # false if '--quiet' specified
verbose={{*false*}}

[bash]$ ruby ex10.rb flagtest2 {{*--quiet=on*}}   # error
{{*[ERROR] --quiet=on: Unexpected argument.*}}
```

In above example, ``--quiet=on`` will be error because option is defined as
``@option.(:verbose, "-q, --quiet", ...)`` which means that this option takes no arguments.
If you want to allow ``--quiet=on``, specify option argument and ``type: TrueClass``.


```ruby
  ...(snip)...

  @action.("flag test")
  @option.(:verbose, "-q, --quiet{{*[=<on|off>]*}}", "quiet mode",  # !!!!
                     {{*type: TrueClass*}}, value: false)           # !!!!
  def flagtest2(verbose: true)
    puts "verbose=#{verbose.inspect}"
  end

  ...(snip)...
```


=== Prefix of Action Name

* ``prefix "foo:bar:"`` in action class adds prefix ``foo:bar:`` to each action name.
* Prefix name should end with ``:``. For example, ``prefix "foo:"`` is OK but ``prefix "foo"`` will be error.
* Method name ``def baz__test()`` with ``prefix: "foo:bar"`` results in action name ``foo:bar:baz:test``.

File: ex11.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action
  {{*prefix "foo:bar:"*}}           # !!!!

  @action.("test action #1")
  def {{*test1*}}()                 # action name: 'foo:bar:test1'
    puts __method__
  end

  @action.("test action #2")
  def {{*baz__test2*}}()            # action name: 'foo:bar:baz:test2'
    puts __method__
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Output:

```console
[bash]$ ruby ex11.rb {{*foo:bar:test1*}}
test1

[bash]$ ruby ex11.rb {{*foo:bar:baz:test2*}}
baz__test2
```

Help message:

```console
[bash]$ ruby ex11.rb -h
ex11.rb --- sample app

Usage:
  $ ex11.rb [<options>] <action> [<arguments>...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list all actions/options including hidden ones

Actions:
  {{*foo:bar:baz:test2*}}  : test action #2
  {{*foo:bar:test1*}}      : test action #1
  help               : print help message (of action if specified)
```

* ``prefix "foo:bar:", action: "blabla"`` defines ``foo:bar`` action (intead of ``foo:bar:blabla``) with ``blabla()`` method.

File: ex12.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action
  prefix "foo:bar:", {{*action: "test3"*}}      # !!!!

  @action.("test action #1")
  def test1()                 # action name: 'foo:bar:test1'
    puts __method__
  end

  @action.("test action #3")
  def {{*test3*}}()                 # action name: 'foo:bar'
    puts __method__
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Output:

```console
[bash]$ ruby ex12.rb foo:bar:test1
test1

[bash]$ ruby ex12.rb {{*foo:bar:test3*}}
[ERROR] foo:bar:test3: Action not found.

[bash]$ ruby ex12.rb {{*foo:bar*}}
test3
```

Help message:

```console
[bash]$ ruby ex12.rb -h
ex12.rb --- sample app

Usage:
  $ ex12.rb [<options>] <action> [<arguments>...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list all actions/options including hidden ones

Actions:
  {{*foo:bar*}}            : test action #3
  foo:bar:test1      : test action #1
  help               : print help message (of action if specified)
```


=== Invoke Other Action

* ``run_action_anyway()`` invokes other action.
* ``run_action_once()`` invokes other action only once.
  This is equivarent to 'prerequisite task' feature in task runner application.

File: ex13.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("create build dir")
  def {{*prepare*}}()
    puts {{*"rm -rf build"*}}
    puts {{*"mkdir build"*}}
  end

  @action.("build something")
  def build()
    {{*run_action_once("prepare")*}}        # !!!!
    {{*run_action_once("prepare")*}}        # skipped because already invoked
    puts "echo 'README' > build/README.txt"
    puts "zip -r build.zip build"
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Output:

```console
[bash]$ ruby ex13.rb build
{{*rm -rf build*}}                          # invoked only once!!!!
{{*mkdir build*}}                           # invoked only once!!!!
echo 'README' > build/README.txt
zip -r build.zip build
```

* When looped action is detected, Benry::CmdApp aborts action.

File: ex14.rb

```ruby
require 'benry/cmdapp'

class LoopedAction < Benry::CmdApp::Action

  @action.("test #1")
  def test1()
    run_action_once("test2")
  end

  @action.("test #2")
  def test2()
    run_action_once("test3")
  end

  @action.("test #3")
  def test3()
    {{*run_action_once("test1")*}}          # !!!!
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Output:

```console
[bash]$ ruby ex14.rb test1
{{*[ERROR] test1: Looped action detected.*}}

[bash]$ ruby ex14.rb test3
{{*[ERROR] test3: Looped action detected.*}}
```


=== Alias of Action

* Alias of action provides alternative short name of action.

File: ex15.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action
  {{*prefix "foo:bar:"*}}

  @action.("test action #1")
  def {{*test1*}}()                 # action name: 'foo:bar:test1'
    puts __method__
  end

end

{{*Benry::CmdApp.define_alias "test", "foo:bar:test1"*}}   # !!!!

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Output:

```console
[bash]$ ruby ex15.rb {{*test*}}             # alias name
test1

[bash]$ ruby ex15.rb {{*foo:bar:test1*}}    # original action name
test1
```

Help message:

```console
[bash]$ ruby ex15.rb -h
ex15.rb --- sample app

Usage:
  $ ex15.rb [<options>] <action> [<arguments>...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list all actions/options including hidden ones

Actions:
  foo:bar:test1      : test action #1
  help               : print help message (of action if specified)
  {{*test               : alias of 'foo:bar:test1'*}}
```

* Alias can include positional and keyword arguments in definition.

File: ex16.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class MyAction < Benry::CmdApp::Action

  @action.("print greeting message")
  @option.(:lang, "-l, --lang=<lang>", "language", enum: ["en", "fr", "it"])
  def hello(user="world", lang: "en")
    case lang
    when "en" ; puts "Hello, #{user}!"
    when "fr" ; puts "Bonjour, #{user}!"
    when "it" ; puts "Ciao, #{user}!"
    else
      raise "#{lang}: unknown language."
    end
  end

end

Benry::CmdApp.define_alias("bonjour", "hello", {{*"--lang=fr"*}})        # !!!!
Benry::CmdApp.define_alias("ciao"   , "hello", {{*"Bob", "-l", "it"*}})  # !!!!

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Output:

```console
[bash]$ ruby ex16.rb hello
Hello, world!

[bash]$ ruby ex16.rb {{*bonjour*}}           # !!!!
Bonjour, world!

[bash]$ ruby ex16.rb {{*bonjour Alice*}}     # !!!!
Bonjour, Alice!

[bash]$ ruby ex16.rb {{*ciao*}}              # !!!!
Ciao, Bob!
```


=== Default Action

* ``config.default_action = "test1"`` defines default action.
  In this case, action ``test1`` will be invoked if action name not specified in command-line.
* Default action name is shown in help message.

File: ex17.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("test action #1")
  def test1()
    puts __method__
  end

end

config = Benry::CmdApp::Config.new("sample app")
{{*config.default_action = "test1"*}}     # !!!!
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Output:

```console
[bash]$ ruby ex17.rb test1
test1

[bash]$ {{*ruby ex17.rb*}}               # no action name!!!!
test1
```

Help message:

```console
[bash]$ ruby ex17.rb -h
ex17.rb --- sample app

Usage:
  $ ex17.rb [<options>] <action> [<arguments>...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list all actions/options including hidden ones

Actions: {{*(default: test1)*}}                   # !!!!
  help               : print help message (of action if specified)
  test1              : test action #1
```


=== Action List and Prefix List

When ``config.default_action`` is not specified, Benry-CmdAction lists action names if action name is not specified in command-line.

File: ex18.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("test action #1")
  def {{*test1*}}()
  end

  {{*prefix "foo:"*}} do

    @action.("test action #2")
    def {{*test2*}}()
    end

  end

  {{*prefix "bar:"*}} do

    @action.("test action #3")
    def {{*test3*}}()
    end

    {{*prefix "baz:"*}} do

      @action.("test action #4")
      def {{*test4*}}()
      end

    end

  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Output:

```console
[bash]$ ruby ex18.rb            # no action name!!!!
Actions:
  {{*bar:baz:test4*}}      : test action #4
  {{*bar:test3*}}          : test action #3
  {{*foo:test2*}}          : test action #2
  {{*help*}}               : print help message (of action if specified)
  {{*test1*}}              : test action #1
```

If prefix (such as ``xxx:``) is specified instead of action name,
Benry-CmdApp lists action names which have that prefix.

Output:

```console
[bash]$ ruby ex18.rb {{*foo:*}}              # !!!!
Actions:
  {{*foo:test2*}}          : test action #2

[bash]$ ruby ex18.rb {{*bar:*}}              # !!!!
Actions:
  {{*bar:baz:test4*}}      : test action #4
  {{*bar:test3*}}          : test action #3
```

If ``:`` is specified instead of action name, Benry-CmdApp lists top prefixes of action names and number of actions under the each prefix.

Outuput:

```console
[bash]$ ruby ex18.rb {{*:*}}                 # !!!!
Prefixes:
  {{*bar: (2)*}}           # !!! two actions ('bar:test3' and 'bar:baz:test4')
  {{*foo: (1)*}}           # !!! one action ('foo:text2')
```


=== Hidden Action

* If ``hidden: true`` keyword argument passed to ``@action.()``,
  or action method is private, then Benry::CmdApp regards that action as hidden.
* Hidden actions are not shown in help message nor action list by default.
* Hidden actions are shown when ``-a`` or ``--all`` option is specified in command-line.

File: ex20.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("test action #1")
  def test1()
    puts __method__
  end

  @action.("test action #2", {{*hidden: true*}})  # !!!!
  def test2()
    puts __method__
  end

  {{*private*}}                      # !!!!

  @action.("test action #3")
  def test3()
    puts __method__
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Action list (without ``-a`` nor ``--all``):

```console
[bash]$ ruby ex20.rb
Actions:
  help               : print help message (of action if specified)
  test1              : test action #1
```

Action list (with ``-a`` or ``--all``):

```console
[bash]$ ruby ex20.rb {{*--all*}}      # !!!!
Actions:
  help               : print help message (of action if specified)
  test1              : test action #1
  {{*test2              : test action #2*}}          # !!!!
  {{*test3              : test action #3*}}          # !!!!
```


=== Hidden Option

* Options defined with ``hidden: true`` keyword argument are treated as hidden option.
* Hidden options are not shown in help message of action.
* Hidden options are shown when ``-a`` or ``--all`` option is specified in command-line.

File: ex21.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("test action")
  @option.(:verbose, "-v", "verbose mode")
  @option.(:debug , "-D", "debug mode", {{*hidden: true*}})      # !!!!
  def test1(verbose: false, debug: false)
    puts "verbose=#{verbose}, debug=#{_debug}"
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Help message (without ``-a`` nor ``--all``):

```console
[bash]$ ruby ex21.rb -h test1
ex21.rb test1 --- test action

Usage:
  $ ex21.rb test1 [<options>]

Options:
  -v                 : verbose mode
```

Help message (with ``-a`` or ``--all``)

```console
[bash]$ ruby ex21.rb -h {{*--all*}} test1           # !!!!
ex21.rb test1 --- test action

Usage:
  $ ex21.rb test1 [<options>]

Options:
  -v                 : verbose mode
  {{*-D                 : debug mode*}}             # !!!!
```



== Configuratoin and Customization


=== Application Configuration

``Benry::CmdApp::Config`` class configures application behaviour.

* ``config.app_desc = "..."`` sets command description which is shown in help message. (required)
* ``config.app_version = "1.0.0"`` enables ``-V`` and ``--version`` option, and prints version number if ``-V`` or ``--version`` option specified. (default: ``nil``)
* ``config.app_command = "<command>"`` sets command name which is shown in help message. (default: ``File.basname($0)``)
* ``config.app_name = "<string>"`` sets application name which is shown in help message. (default: same as ``config.app_command``)
* ``config.app_usage = "<text>" (or ``["<text1>", "<text2>", ...]``) sets usage string in help message. (default: ``" <action> [<arguments>...]"``)
* ``config.app_detail = "<text>"`` sets detailed description of command which is showin in help message. (default: ``nil``)
* ``config.help_postamble = {"<Title>:" => "<text>"}`` sets postamble of help message, such as 'Example:' or 'Tips:'. (default: ``nil``)
* ``config.default_action = "<action>"`` sets default action name. (default: ``nil``)
* ``config.option_list = true`` enables ``-l`` and ``--list`` options. (default: ``true``)
* ``config.option_all = true`` enables ``-a`` and ``--all`` options which shows private (hidden) actions and options into help message. (default: ``true``)
* ``config.option_verbose = true`` enables ``-v`` and ``--verbose`` options which sets ``$QUIET_MODE = false``. (default: ``false``)
* ``config.option_quiet = true`` enables ``-q`` and ``--quiet`` options which sets ``$QUIET_MODE = true``. (default: ``false``)
* ``config.option_color = true`` enables ``--color[=<on|off>]`` option which sets ``$COLOR_MODE = true/false``. This affects to help message colorized or not. (default: ``false``)
* ``config.option_debug = true`` enables ``-D`` and ``--debug`` options which sets ``$DEBUG_MODE = true``. (default: ``false``)
* ``config.option_trace = true`` enables ``-T`` and ``--trace`` options. Entering into and exitting from action are reported when trace mode is on. (default: ``false``)
* ``config.format_option = "  %-18s : %s"`` sets format of options in help message. (default: ``"  %-18s : %s"``)
* ``config.format_action = "  %-18s : %s"`` sets format of actions in help message. (default: ``"  %-18s : %s"``)
* ``config.format_usage = "  $ %s"`` sets format of usage in help message. (default: ``"  $ %s"``)

File: ex22.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

config = Benry::CmdApp::Config.new("sample app", "1.0.0", app_name: "Sample App")
config.each(sort: false) do |name, val|
  puts "config.%-20s = %s" % [name, val.inspect]
end
```

Output:

```console
[bash]$ ruby ex22.rb
config.{{*app_desc*}}             = "sample app"
config.{{*app_version*}}          = "1.0.0"
config.{{*app_name*}}             = "Sample App"
config.{{*app_command*}}          = "ex22.rb"             # == File.basename($0)
config.{{*app_usage*}}            = nil
config.{{*app_detail*}}           = nil
config.{{*default_action*}}       = nil
config.{{*help_postamble*}}       = nil
config.{{*format_option*}}        = "  %-18s : %s"
config.{{*format_action*}}        = "  %-18s : %s"
config.{{*format_usage*}}         = "  $ %s"
config.{{*deco_command*}}         = "\e[1m%s\e[0m"        # bold
config.{{*deco_header*}}          = "\e[1;34m%s\e[0m"     # bold, blue
config.{{*deco_strong*}}          = "\e[1m%s\e[0m"        # bold
config.{{*deco_weak*}}            = "\e[2m%s\e[0m"        # gray color
config.{{*deco_hidden*}}          = "\e[2m%s\e[0m"        # gray color
config.{{*deco_error*}}           = "\e[31m%s\e[0m"       # red
config.{{*option_verbose*}}       = false
config.{{*option_quiet*}}         = false
config.{{*option_color*}}         = false
config.{{*option_debug*}}         = nil
config.{{*option_trace*}}         = false
config.{{*color_mode*}}           = nil
config.{{*trace_mode*}}           = nil
```


=== Customization of Global Options

To add custom global options:

* (1) Create a global option schema object.
* (2) Add custom options to it.
* (3) Pass it to ``Application.new()``.

File: ex23.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("test action")
  def test1()
    puts __method__
  end

end

## (1) create global option shema
config = Benry::CmdApp::Config.new("sample app")
{{*schema = Benry::CmdApp::GlobalOptionSchema.new(config)*}}  # !!!!

## (2) add custom options to it
{{*schema.add(:logging, "--logging", "enable logging")*}}    # !!!!

## (3) pass it to ``Application.new()``
app = Benry::CmdApp::Application.new(config, {{*schema*}})   # !!!!

exit app.main()
```

Help message:

```console
[bash]$ ruby ex23.rb -h
ex23.rb --- sample app

Usage:
  $ ex23.rb [<options>] <action> [<arguments>...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list all actions/options including hidden ones
  {{*--logging          : enable logging*}}          # !!!!

Actions:
  help               : print help message (of action if specified)
  test1              : test action
```

To customize global options entirely:

* (1) Create empty ``GlobalOptionSchema`` object.
* (2) Add global options as you want.
* (3) Create and execute Application object with it.

File: ex24.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

## (1) Create empty ``GlobalOptionSchema`` object.
{{*schema = Benry::CmdApp::GlobalOptionSchema.new(nil)*}}   # !!!!

## (2) Add global options as you want.
{{*schema.add*}}(:help   , "-h, --help"   , "print help message")
{{*schema.add*}}(:version, "-V, --version", "print version")
{{*schema.add*}}(:list   , "-l, --list"   , "list actions")
{{*schema.add*}}(:all    , "-a, --all"    , "list all actions/options including hidden ones")
{{*schema.add*}}(:verbose, "-v, --verbose", "verbose mode")
{{*schema.add*}}(:quiet  , "-q, --quiet"  , "quiet mode")
{{*schema.add*}}(:color  , "--color[=<on|off>]", "enable/disable color mode", type: TrueClass)
{{*schema.add*}}(:debug  , "-D, --debug"  , "set $DEBUG_MODE to true")
{{*schema.add*}}(:trace  , "-T, --trace"  , "report enter into and exit from action")

## (3) Create and execute Application object with it.
config = Benry::CmdApp::Config.new("sample app", "1.0.0")
app = Benry::CmdApp::Application.new(config, {{*schema*}})  # !!!!
exit app.main()
```

Help message:

```console
[bash]$ ruby ex24.rb -h
ex24.rb (1.0.0) --- sample app

Usage:
  $ ex24.rb [<options>] <action> [<arguments>...]

Options:
  {{*-h, --help         : print help message*}}
  {{*-V, --version      : print version*}}
  {{*-l, --list         : list actions*}}
  {{*-a, --all          : list all actions/options including hidden ones*}}
  {{*-v, --verbose      : verbose mode*}}
  {{*-q, --quiet        : quiet mode*}}
  {{*--color[=<on|off>] : enable/disable color mode*}}
  {{*-D, --debug        : set $DEBUG_MODE to true*}}
  {{*-T, --trace        : report enter into and exit from action*}}

Actions:
  help               : print help message (of action if specified)
```



=== Customization of Global Option Behaviour

* (1) Define subclass of ``Application`` class.
* (2) Override ``#toggle_global_options()`` method.
* (3) Create and execute subclass object of ``Application``.

File: ex25.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

## (1) Define subclass of ``Application`` class.
{{*class MyApplication < Benry::CmdApp::Application*}}

  ## (2) Override ``#toggle_global_options()`` method.
  {{*def toggle_global_options(global_opts)*}}
    {{*status_code = super*}}
    {{*return status_code if status_code*}}  # `return 0` means "stop process successfully",
                                       # `return 1` means "stop process as failed".
    if global_opts[:logging]
      require 'logger'
      $logger = Logger.new(STDOUT)
    end
    {{*return nil*}}                   # `return nil` means "continue process".
  end

end

## (3) Create and execute subclass object of ``Application``.
config = Benry::CmdApp::Config.new("sample app")
app = {{*MyApplication.new(config)*}}            # !!!!
exit app.main()
```

Of course, prepending custom module to Application class is also effective way.

File: ex26.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

{{*module MyApplicationMod*}}

  {{*def toggle_global_options(global_opts)*}}
    # ....
  end

end

Benry::CmdApp::Application{{*.prepend(MyApplicationMod)*}}   # !!!!

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```


=== Custom Hook of Application

* (1) Define subclass of Application class.
* (2) Override ``#handle_action()`` method.
* (3) Create and execute custom application object.

File: ex27.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("test action")
  def test1()
    $logger.info("logging message") if $logger
  end

end

## (1) Define subclass of Application class
{{*class MyApplication < Benry::CmdApp::Application*}}   # !!!!

  ## (2) Override method
  {{*def handle_action(action, args)*}}                  # !!!!
    #p @config
    $logger.debug("action=#{action}, args=#{args.inspect}") if $logger
    {{*super*}}                                          # !!!!
  end

end

## (3) create and execute custom application object
config = Benry::CmdApp::Config.new("sample app")
schema = Benry::CmdApp::GlobalOptionSchema.new(config)
schema.add(:logging, "--logging", "enable logging")
app = {{*MyApplication*}}.new(config, schema)             # !!!!
exit app.main()
```

<!--

* [EXPERIMENTAL] Instead of defining subclass of Application, you can pass callback block to Application object.

File: ex28.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("test action")
  def test1()
    $logger.info("logging message") if $logger
  end

end

config = Benry::CmdApp::Config.new("sample app")
schema = Benry::CmdApp::GlobalOptionSchema.new(config)
schema.add(:logging, "--logging", "enable logging")
app = Benry::CmdApp::Application.new(config, schema) {{*do*}}   # !!!!
  {{*|args, global_opts, config|*}}                             # !!!!
  if global_opts[:logging]                                # !!!!
    require 'logger'                                      # !!!!
    $logger = Logger.new(STDOUT)                          # !!!!
  end                                                     # !!!!
  nil                                                     # !!!!
end                                                       # !!!!
exit app.main()
```

-->


=== Customization of Application Help Message

If you want to just add more text into application help message,
set ``config.app_detail`` and/or ``config.help_postamble``.

File: ex29.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("test action #1")
  def hello(user="world")
    puts "Hello, #{user}!"
  end

end

config = Benry::CmdApp::Config.new("sample app")
{{*config.app_detail = "See https://...."*}}            # !!!!
{{*config.help_postamble = [*}}                         # !!!!
{{*  {"Example:" => "  $ <command> hello Alice\n"},*}}  # !!!!
{{*  "(Tips: ....)",*}}                                 # !!!!
{{*]*}}                                                 # !!!!

app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Help message:

```console
[bash]$ ruby ex29.rb -h
ex29.rb --- sample app

{{*See https://....*}}

Usage:
  $ ex29.rb [<options>] <action> [<arguments>...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list all actions/options including hidden ones

Actions:
  hello              : test action #1

{{*Example:*}}
  {{*$ <command> hello Alice*}}

{{*(Tips: ....)*}}
```

If you want to change behaviour of building command help message:

* (1) Define subclass of ``Benry::CmdApp::ApplicationHelpBuilder`` class.
* (2) Override methods.
* (3) Create an instance object of the class.
* (4) Pass it to Application object.

File: ex30.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("print greeting message")
  def hello(user="world")
    puts "Hello, #{user}!"
  end

end

## (1) Define subclass of ``Benry::CmdApp::ApplicationHelpBuilder`` class.
{{*class MyAppHelpBuilder < Benry::CmdApp::ApplicationHelpBuilder*}}

  ## (2) Override methods.
  def {{*build_help_message*}}(gschema, all: false)
    super
  end
  def {{*help_message__preamble*}}()
    super
  end
  def {{*help_message__usage*}}()
    super
  end
  def {{*help_message__options*}}(gschema, all: false)
    super
  end
  def {{*help_message__actions*}}(all: false)
    super
  end
  def {{*help_message__postamble*}}()
    super
  end
end

## (3) Create an instance object of the class.
config = Benry::CmdApp::Config.new("sample app")
schema = Benry::CmdApp::GlobalOptionSchema.new(config)
schema.add(:logging, "--logging", "enable logging")
{{*app_help_builder = MyAppHelpBuilder.new(config)*}}      # !!!!

## (4) Pass it to Application object.
app = Benry::CmdApp::Application.new(config, schema, {{*app_help_builder*}}) # !!!!
exit app.main()
```

More simple way:

* (1) Create a module and override methods of ``Benry::CmdApp::ApplicationHelpBuilder`` class.
* (2) Prepend it to ``Benry::CmdApp::ApplicationHelpBuilder`` class.
* (3) Create and execute Application object.

File: ex31.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("print greeting message")
  def hello(user="world")
    puts "Hello, #{user}!"
  end

end

## (1) Create a module and override methods of ``ApplicationHelpBuilder`` class.
{{*module MyHelpBuilderMod*}}
  def build_help_message(all=false, format=nil)
    super
  end
  def build_help_message(gschema, all: false)
    super
  end
  def help_message__preamble()
    super
  end
  def help_message__usage()
    super
  end
  def help_message__options(gschema, all: false)
    super
  end
  def help_message__actions(all: false)
    super
  end
  def help_message__postamble()
    super
  end
end

## (2) Prepend it to ``Benry::CmdApp::ApplicationHelpBuilder`` class.
{{*Benry::CmdApp::ApplicationHelpBuilder.prepend(MyHelpBuilderMod)*}}

## (3) Create and execute Application object.
config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```


=== Customization of Action Help Message

If you want to just add more text into action help message,
pass ``detail:`` and/or ``postamble:`` keyword arguments to ``@action.()``.

File: ex32.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("test action #1",
           {{*detail: "See https://...."*}},           # !!!!
           {{*postamble: {"Example:" => "  ...."}*}})  # !!!!
  def hello(user="world")
    puts "Hello, #{user}!"
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Help message:

```console
[bash]$ ruby ex32.rb -h hello
ex32.rb hello --- test action #1

{{*See https://....*}}                  # !!!!

Usage:
  $ ex32.rb hello [<user>]

{{*Example:*}}
  {{*....*}}                            # !!!!
```

If you want to change behaviour of building action help message:

* (1) Define subclass of ``ActionHelpBuilder`` class.
* (2) Override methods.
* (3) Create an instance object of the class.
* (4) Pass it to Application object.

File: ex33.rb

```ruby
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("print greeting message")
  def hello(user="world")
    puts "Hello, #{user}!"
  end

end

## (1) Define subclass of ``ActionHelpBuilder`` class.
{{*class MyActionHelpBuilder < Benry::CmdApp::ActionHelpBuilder*}}
  ## (2) Override methods.
  def {{*build_help_message*}}(metadata, all: false)
    super
  end
  def {{*help_message__preamble*}}(metadata)
    super
  end
  def {{*help_message__usage*}}(metadata, all: false)
    super
  end
  def {{*help_message__options*}}(metadata, all: false)
    super
  end
  def {{*help_message__postamble*}}(metadata)
    super
  end
end

## (3) Create an instance object of the class.
config = Benry::CmdApp::Config.new("sample app")
{{*action_help_builder = MyActionHelpBuilder.new(config)*}}

## (4) Pass it to Application object.
schema = Benry::CmdApp::GlobalOptionSchema.new(config)
app = Benry::CmdApp::Application.new(config, schema, nil, {{*action_help_builder*}})
exit app.main()
```

Another way:

* (1) Create a module and override methods of ``Benry::CmdApp::ActionHelpBuilder`` class.
* (2) Prepend it to ``Benry::CmdApp::ActionHelpBuilder`` class.
* (3) Create and execute Application object.

File: ex34.rb

```ruby
# coding: utf-8
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("print greeting message")
  def hello(user="world")
    puts "Hello, #{user}!"
  end

end

## (1) Create a module and override methods of ``ActionHelpBuilder`` class.
{{*module MyActionHelpBuilderMod*}}
  def {{*build_help_message*}}(metadata, all: false)
    super
  end
  def {{*help_message__preamble*}}(metadata)
    super
  end
  def {{*help_message__usage*}}(metadata, all: false)
    super
  end
  def {{*help_message__options*}}(metadata, all: false)
    super
  end
  def {{*help_message__postamble*}}(metadata)
    super
  end
end

## (2) Prepend it to ``Benry::CmdApp::ActionHelpBuilder`` class.
Benry::CmdApp::ActionHelpBuilder{{*.prepend(MyActionHelpBuilderMod)*}}  # !!!!

## (3) Create and execute Application object.
config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```



== Q & A


=== Q: How to Append Some Tasks to Existing Action?

A: (a) Use method alias, or (b) use prepend.

File: ex41.rb

```ruby
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("test action #1")
  def hello(user="world")
    puts "Hello, #{user}!"
  end

  @action.("test action #2")
  def hi(user="world")
    puts "Hi, #{user}!"
  end

end

## (a) use method alias
class SampleAction               # open existing class
  {{*alias __old_hello hello*}}        # alias of existing method
  def {{*hello*}}(user="world")        # override existing method
    puts "---- >8 ---- >8 ----"
    {{*__old_hello(user)*}}            # call original method
    puts "---- 8< ---- 8< ----"
  end
end

## (b) use prepend
{{*module SampleMod*}}                 # define new module
  def {{*hi*}}(user="world")           # override existing method
    puts "~~~~ >8 ~~~~ >8 ~~~~"
    {{*super*}}                        # call original method
    puts "~~~~ 8< ~~~~ 8< ~~~~"
  end
end
SampleAction{{*.prepend(SampleMod)*}}  # prepend it to existing class

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Output:

```console
[bash]$ ruby ex41.rb hello
---- >8 ---- >8 ----
Hello, world!
---- 8< ---- 8< ----

[bash]$ ruby ex41.rb hi Alice
~~~~ >8 ~~~~ >8 ~~~~
Hi, Alice!
~~~~ 8< ~~~~ 8< ~~~~
```


=== Q: How to Delete Existing Action/Alias?

A: Call ``Benry::CmdApp.undef_action("<action>")`` or ``Benry::CmdApp.undef_alias("<alias>")``.


=== Q: How to Re-define Existing Action?

A: Remove existing action at first, and re-define action.

File: ex42.rb

```ruby
require 'benry/cmdapp'

class {{*SampleAction*}} < Benry::CmdApp::Action

  @action.("sample action")
  def {{*hello*}}()                               # !!!!
    puts "Hello, world!"
  end

end

Benry::CmdApp{{*.undef_action("hello")*}}        # !!!!

class {{*OtherAction*}} < Benry::CmdApp::Action

  @action.("other action")                  # !!!!
  def {{*hello*}}()                               # !!!!
    puts "Ciao, world!"
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Help message:

```console
[bash]$ ruby ex42.rb -h
ex42.rb --- sample app

Usage:
  $ ex42.rb [<options>] <action> [<arguments>...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list all actions/options including hidden ones

Actions:
  {{*hello              : other action*}}       # !!!!
  help               : print help message (of action if specified)
```


=== Q: How to Show Entering Into or Exitting From Action?

A: Set ``config.option_trace = true`` and pass ``-T`` (or ``--trace``) option.

File: ex43.rb

```ruby
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("preparation")
  def prepare()
    puts "... prepare something ..."
  end

  @action.("build")
  def build()
    run_action_once("prepare")
    puts "... build something ..."
  end

end

config = Benry::CmdApp::Config.new("sample app")
{{*config.option_trace = true*}}                          # !!!!
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Output:

```console
[bash]$ ruby ex43.rb -T build           # !!!!
{{*### enter: build*}}
{{*### enter: prepare*}}
... prepare something ...
{{*### exit:  prepare*}}
... build something ...
{{*### exit:  build*}}
```


=== Q: How to Enable/Disable Color Mode?

A: Set ``config.option_color = true`` and pass ``--color=on`` or ``--color=off`` option.

File: ex44.rb

```ruby
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("print greeting message")
  def hello(user="world")
    puts "Hello, #{user}!"
  end

end

config = Benry::CmdApp::Config.new("sample app")
{{*config.option_color = true*}}                       # !!!!
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Help message:

```console
[bash]$ ruby ex44.rb -h
ex44.rb --- sample app

Usage:
  $ ex44.rb [<options>] <action> [<arguments>...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list all actions/options including hidden ones
  {{*--color[=<on|off>] : enable/disable color*}}      # !!!!

Actions:
  hello              : print greeting message

[bash]$ ruby ex44.rb -h {{*--color=off*}}              # !!!!

[bash]$ ruby ex44.rb -h {{*--color=on*}}               # !!!!
[bash]$ ruby ex44.rb -h {{*--color*}}                  # !!!!
```


=== Q: How to Define Multiple Option, like ``-I`` Option of Ruby?

A: Provide block parameter on ``@option.()``.

File: ex45.rb

```ruby
require 'benry/cmdapp'

class TestAction < Benry::CmdApp::Action

  @action.("multiple option test")
  @option.(:path, "-I <path>", "path") {{*{|options, key, val|*}}  # !!!!
    {{*arr = options[key] || []*}}                                 # !!!!
    {{*arr << val*}}                                               # !!!!
    {{*arr*}}                                                      # !!!!
    ## or:                                                   # !!!!
    #{{*(options[key] || []) << val*}}                             # !!!!
  {{*}*}}                                                          # !!!!
  def test_(path: [])
    puts "path=#{path.inspect}"     #=> path=["/tmp", "/var/tmp"]
  end

end

config = Benry::CmdApp::Config.new("test app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Output:

```console
[bash]$ ruby ex45.rb test {{*-I /tmp -I /var/tmp*}}     # !!!!
path=["/tmp", "/var/tmp"]                         # !!!!
```


=== Q: How to Specify Detailed Description of Option?

A: Add ``detail:`` keyword argument to ``@option.()``.

File: ex46.rb

```ruby
require 'benry/cmdapp'

class TestAction < Benry::CmdApp::Action

  @action.("detailed description test")
  @option.(:mode, "-m <mode>", "output mode", {{*detail:*}} <<"END")
   v, verbose: print many output
   q, quiet:   print litte output
   c, compact: print summary output
END
  def test_(mode: nil)
    puts "mode=#{mode.inspect}"
  end

end

config = Benry::CmdApp::Config.new("test app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Help message:

```console
[bash]$ ruby ex46.rb -h test
ex46.rb test --- detailed description test

Usage:
  $ ex46.rb test [<options>]

Options:
  -m <mode>          : output mode
                          {{*v, verbose: print many output*}}
                          {{*q, quiet:   print litte output*}}
                          {{*c, compact: print summary output*}}
```


=== Q: How to Copy All Options from Other Action?

A: Use ``@copy_options.()``.

File: ex47.rb

```ruby
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("test action #1")
  @option.(:verbose, "-v, --verbose", "verbose mode")
  @option.(:file, "-f, --file=<file>", "filename")
  @option.(:indent, "-i, --indent[=<N>]", "indent")
  def test1(verbose: false, file: nil, indent: nil)
    puts "verbose=#{verbose}, file=#{file}, indent=#{indent}"
  end

  @action.("test action #2")
  {{*@copy_options.("test1")*}}         # !!!! copy options from test1 !!!!
  @option.(:debug, "-D, --debug", "debug mode")
  def test2(verbose: false, file: nil, indent: nil, debug: false)
    puts "verbose=#{verbose}, file=#{file}, indent=#{indent}, debug=#{debug}"
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Help message of ``test2`` action:

```console
[bash]$ ruby ex47.rb -h test2
ex47.rb test2 --- test action #2

Usage:
  $ ex47.rb test2 [<options>]

Options:
  -v, --verbose      : verbose mode     # copied!!
  -f, --file=<file>  : filename         # copied!!
  -i, --indent[=<N>] : indent           # copied!!
  -D, --debug        : debug mode
```


=== Q: What is the Difference Between ``prefix(alias_of:)`` and ``prefix(action:)``?

A: The former defines an alias, and the latter doesn't.

File: ex48.rb

```ruby
require 'benry/cmdapp'

class AaaAction < Benry::CmdApp::Action
  prefix "aaa:", {{*alias_of:*}} "print"

  @action.("test #1")
  def print_()
    puts "test"
  end

end

class BbbAction < Benry::CmdApp::Action
  prefix "bbb:", {{*action:*}} "print"

  @action.("test #2")
  def print_()
    puts "test"
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Help message:

```console
[bash]$ ruby ex48.rb -h
ex48.rb --- sample app

Usage:
  $ ex48.rb [<options>] <action> [<arguments>...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list all actions/options including hidden ones

Actions:
  {{*aaa                : alias of 'aaa:print' action*}}    # !!!!
  aaa:print          : test #1
  {{*bbb                : test #2*}}                        # !!!!
  help               : print help message (of action if specified)
```

In the above example, alias ``aaa`` is defined due to ``prefix(alias_of:)``,
and action ``bbb`` is not an alias due to ``prefix(action:)``.


=== Q: How to Change Order of Options in Help Message?

A: Call ``GlobalOptionSchema#reorder_options!()``.

File: ex49.rb

```ruby
require 'benry/cmdapp'

config = Benry::CmdApp::Config.new("sample app", "1.0.0",
  option_verbose:   true,
  option_quiet:     true,
  option_color:     true,
)
schema = Benry::CmdApp::GlobalOptionSchema.new(config)
{{*keys = [:verbose, :quiet, :color, :help, :version, :all, :list]*}}  # !!!!
{{*schema.reorder_options!(*keys)*}}               # !!!!
app = Benry::CmdApp::Application.new(config, schema)
## or:
#app = Benry::CmdApp::Application.new(config)
#{{*app.schema.reorder_options!(*keys)*}}          # !!!!
exit app.main()
```

Help message:

```console
[bash]$ ruby ex49.rb -h
ex49.rb (1.0.0) --- sample app

Usage:
  $ ex49.rb [<options>] <action> [<arguments>...]

Options:
  -v, --verbose      : verbose mode
  -q, --quiet        : quiet mode
  --color[=<on|off>] : color mode
  -h, --help         : print help message (of action if specified)
  -V, --version      : print version
  -a, --all          : list all actions/options including hidden ones
  -l, --list         : list actions

Actions:
  help               : print help message (of action if specified)
```


=== Q: Is It Possible to Make Action Names Emphasised or Weaken?

A: Yes. When you pass ``important: true`` to ``@action.()``, that action will be printed with unerline in help message. When you pass ``important: false``, that action will be printed in gray color.

File: ex50.rb

```ruby
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("empasized", {{*important: true*}})   # !!!!
  def test1()
  end

  @action.("weaken", {{*important: false*}})   # !!!!
  def test2()
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```

Help message:

```console
[bash]$ ruby ex50.rb -h
ex50.rb --- sample app

Usage:
  $ ex50.rb [<options>] <action> [<arguments>...]

Options:
  -h, --help         : print help message (of action if specified)
  -l, --list         : list actions
  -a, --all          : list all actions/options including hidden ones

Actions:
  help               : print help message (of action if specified)
  {{*test1              : empasized*}}     # !!!! bold font !!!!
  {{*test2              : weaken*}}        # !!!! gray color !!!!
```


=== Q: Is It Possible to Add Metadata to Action or Option?

A: Yes. Pass ``tag:`` keyword argument to ``@action.()`` or ``@option.()``.

* ``tag:`` keyword argument accept any type of value such as symbol, string, array, and so on.
* Currenty, Benry::CmdApp doesn't provide the good way to use it effectively.
  This feature may be used by command-line application or framework based on Benry::CmdApp.

File: ex51.rb

```ruby
require 'benry/cmdapp'

class SampleAction < Benry::CmdApp::Action

  @action.("print greeting message", {{*tag: :important*}})            # !!!!
  @option.(:repeat, "-r <N>", "repeat N times", {{*tag: :important*}}) # !!!!
  def hello(user="world", repeat: nil)
    (repeat || 1).times do
      puts "Hello, #{user}!"
    end
  end

end

config = Benry::CmdApp::Config.new("sample app")
app = Benry::CmdApp::Application.new(config)
exit app.main()
```


=== Q: How to Make Error Messages I18Ned?

A: Currently not supported. May be supported in the future release.




== License and Copyright

* $License: MIT License $
* $Copyright: copyright(c) 2023 kwatch@gmail.com $
